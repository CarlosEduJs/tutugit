
<!DOCTYPE html>
<html>
	<head>
		<meta http-equiv="Content-Type" content="text/html; charset=utf-8">
		<title>tutugit: Go Coverage Report</title>
		<style>
			body {
				background: black;
				color: rgb(80, 80, 80);
			}
			body, pre, #legend span {
				font-family: Menlo, monospace;
				font-weight: bold;
			}
			#topbar {
				background: black;
				position: fixed;
				top: 0; left: 0; right: 0;
				height: 42px;
				border-bottom: 1px solid rgb(80, 80, 80);
			}
			#content {
				margin-top: 50px;
			}
			#nav, #legend {
				float: left;
				margin-left: 10px;
			}
			#legend {
				margin-top: 12px;
			}
			#nav {
				margin-top: 10px;
			}
			#legend span {
				margin: 0 5px;
			}
			.cov0 { color: rgb(192, 0, 0) }
.cov1 { color: rgb(128, 128, 128) }
.cov2 { color: rgb(116, 140, 131) }
.cov3 { color: rgb(104, 152, 134) }
.cov4 { color: rgb(92, 164, 137) }
.cov5 { color: rgb(80, 176, 140) }
.cov6 { color: rgb(68, 188, 143) }
.cov7 { color: rgb(56, 200, 146) }
.cov8 { color: rgb(44, 212, 149) }
.cov9 { color: rgb(32, 224, 152) }
.cov10 { color: rgb(20, 236, 155) }

		</style>
	</head>
	<body>
		<div id="topbar">
			<div id="nav">
				<select id="files">
				
				<option value="file0">tutugit/cmd/tutugit/commands.go (0.0%)</option>
				
				<option value="file1">tutugit/cmd/tutugit/demo.go (0.0%)</option>
				
				<option value="file2">tutugit/cmd/tutugit/main.go (0.0%)</option>
				
				<option value="file3">tutugit/cmd/tutugit/model.go (0.0%)</option>
				
				<option value="file4">tutugit/cmd/tutugit/styles.go (0.0%)</option>
				
				<option value="file5">tutugit/cmd/tutugit/update.go (0.0%)</option>
				
				<option value="file6">tutugit/cmd/tutugit/views.go (0.0%)</option>
				
				<option value="file7">tutugit/internal/changelog/changelog.go (90.6%)</option>
				
				<option value="file8">tutugit/internal/config/config.go (80.8%)</option>
				
				<option value="file9">tutugit/internal/diff/diff.go (82.9%)</option>
				
				<option value="file10">tutugit/internal/git/git.go (84.5%)</option>
				
				<option value="file11">tutugit/internal/git/mock.go (0.0%)</option>
				
				<option value="file12">tutugit/internal/hygiene/hygiene.go (92.0%)</option>
				
				<option value="file13">tutugit/internal/workspace/semantic.go (95.5%)</option>
				
				<option value="file14">tutugit/internal/workspace/workspace.go (72.4%)</option>
				
				</select>
			</div>
			<div id="legend">
				<span>not tracked</span>
			
				<span class="cov0">not covered</span>
				<span class="cov8">covered</span>
			
			</div>
		</div>
		<div id="content">
		
		<pre class="file" id="file0" style="display: none">package main

import (
        "context"
        "fmt"
        "os"
        "path/filepath"
        "strings"
        "time"

        "tutugit/internal/changelog"
        "tutugit/internal/diff"
        "tutugit/internal/git"
        "tutugit/internal/workspace"

        tea "github.com/charmbracelet/bubbletea"
)

// Summary commands

func (m model) fetchSummary() tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                ctx, cancel := context.WithTimeout(context.Background(), 15*time.Second)
                defer cancel()
                gen := changelog.NewGenerator(m.git, m.meta)
                rels, err := gen.GenerateFull(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return errMsg(err)
                }</span>
                <span class="cov0" title="0">content := gen.FormatSummary(rels)
                return summaryMsg(content)</span>
        }
}

func (m model) exportMarkdown() tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                ctx, cancel := context.WithTimeout(context.Background(), 15*time.Second)
                defer cancel()
                gen := changelog.NewGenerator(m.git, m.meta)
                rels, err := gen.GenerateFull(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return errMsg(err)
                }</span>
                <span class="cov0" title="0">data := gen.ExportMarkdown(rels)
                path := filepath.Join(".tutugit", "release.md")
                if err := os.WriteFile(path, []byte(data), 0644); err != nil </span><span class="cov0" title="0">{
                        return errMsg(err)
                }</span>
                <span class="cov0" title="0">return successMsg("Exported to .tutugit/release.md!")</span>
        }
}

// Fetch commands for data retrieval

func (m model) fetchHistory() tea.Msg <span class="cov0" title="0">{
        commits, err := m.git.GetLog(context.Background(), defaultHistoryLimit)
        if err != nil </span><span class="cov0" title="0">{
                return errMsg(err)
        }</span>
        <span class="cov0" title="0">return historyMsg(commits)</span>
}

func (m model) fetchReflog() tea.Msg <span class="cov0" title="0">{
        entries, err := m.git.GetReflog(context.Background(), defaultReflogLimit)
        if err != nil </span><span class="cov0" title="0">{
                return errMsg(err)
        }</span>
        <span class="cov0" title="0">return reflogMsg(entries)</span>
}

func (m model) fetchWorktrees() tea.Msg <span class="cov0" title="0">{
        worktrees, err := m.git.ListWorktrees(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                return errMsg(err)
        }</span>
        <span class="cov0" title="0">return worktreesMsg(worktrees)</span>
}

func (m model) fetchRebaseStatus() tea.Msg <span class="cov0" title="0">{
        return rebaseStatusMsg(m.git.IsRebasing(context.Background()))
}</span>

func (m model) fetchRebaseSteps(base string) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                commits, err := m.git.GetCommitsInRange(context.Background(), base, "HEAD")
                if err != nil </span><span class="cov0" title="0">{
                        return errMsg(err)
                }</span>
                <span class="cov0" title="0">steps := make([]git.RebaseStep, len(commits))
                for i, c := range commits </span><span class="cov0" title="0">{
                        steps[i] = git.RebaseStep{
                                Action:  git.ActionPick,
                                Hash:    c.Hash,
                                Message: c.Message,
                        }
                }</span>
                <span class="cov0" title="0">return rebaseStepsMsg(steps)</span>
        }
}

func (m model) fetchBranch() tea.Msg <span class="cov0" title="0">{
        branch, err := m.git.GetCurrentBranch(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                return errMsg(err)
        }</span>
        <span class="cov0" title="0">return branchMsg(branch)</span>
}

func (m model) fetchFiles() tea.Msg <span class="cov0" title="0">{
        files, err := m.git.ParseStatus(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                return errMsg(err)
        }</span>
        <span class="cov0" title="0">return filesMsg(files)</span>
}

func (m model) fetchMeta() tea.Msg <span class="cov0" title="0">{
        meta, err := m.wsManager.Load()
        if err != nil </span><span class="cov0" title="0">{
                return errMsg(err)
        }</span>
        <span class="cov0" title="0">return metaMsg(meta)</span>
}

func (m model) fetchHygiene() tea.Msg <span class="cov0" title="0">{
        report, err := m.hygiene.GetReport(context.Background())
        if err != nil </span><span class="cov0" title="0">{
                return errMsg(err)
        }</span>
        <span class="cov0" title="0">return reportMsg(report)</span>
}

func (m model) fetchDiff(path string, staged bool) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                diff, err := m.git.GetDiff(context.Background(), path, staged)
                if err != nil </span><span class="cov0" title="0">{
                        return errMsg(err)
                }</span>
                <span class="cov0" title="0">return diffMsg(diff)</span>
        }
}

// Action commands (stage, unstage, commit, etc.)
func (m model) stageFile(path string) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                err := m.git.StageFile(context.Background(), path)
                if err != nil </span><span class="cov0" title="0">{
                        return errMsg(err)
                }</span>
                <span class="cov0" title="0">return m.fetchFiles()</span>
        }
}

func (m model) unstageFile(path string) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                err := m.git.UnstageFile(context.Background(), path)
                if err != nil </span><span class="cov0" title="0">{
                        return errMsg(err)
                }</span>
                <span class="cov0" title="0">return m.fetchFiles()</span>
        }
}

func (m model) toggleStage(f git.FileStatus) tea.Cmd <span class="cov0" title="0">{
        if f.Staged </span><span class="cov0" title="0">{
                return m.unstageFile(f.Path)
        }</span>
        <span class="cov0" title="0">return m.stageFile(f.Path)</span>
}

func (m model) doCommit(msg string) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                // Pre-check: anything staged?
                hasStaged := false
                for _, f := range m.files </span><span class="cov0" title="0">{
                        if f.Staged </span><span class="cov0" title="0">{
                                hasStaged = true
                                break</span>
                        }
                }
                <span class="cov0" title="0">if !hasStaged </span><span class="cov0" title="0">{
                        return errMsg(fmt.Errorf("nothing to commit (stage your changes with [space] first)"))
                }</span>

                <span class="cov0" title="0">ctx := context.Background()
                err := m.git.Commit(ctx, msg)
                if err != nil </span><span class="cov0" title="0">{
                        return errMsg(err)
                }</span>

                <span class="cov0" title="0">hash, err := m.git.GetLastCommitHash(ctx)
                if err != nil </span><span class="cov0" title="0">{
                        return errMsg(err)
                }</span>

                // Auto-detect semantic tag from message prefix
                <span class="cov0" title="0">tag := workspace.DetectTag(msg)
                if tag != "none" </span><span class="cov0" title="0">{
                        if err := m.wsManager.AddTag(hash, tag); err != nil </span><span class="cov0" title="0">{
                                return errMsg(err)
                        }</span>
                }

                // Auto-assign to active workspace
                <span class="cov0" title="0">if m.meta != nil &amp;&amp; m.meta.ActiveWorkspace != "" </span><span class="cov0" title="0">{
                        if err := m.wsManager.AddCommitToWorkspace(m.meta.ActiveWorkspace, hash); err != nil </span><span class="cov0" title="0">{
                                return errMsg(err)
                        }</span>
                }

                // Save impact (decided in TUI)
                <span class="cov0" title="0">if err := m.wsManager.AddImpact(hash, m.decidedImpact); err != nil </span><span class="cov0" title="0">{
                        return errMsg(err)
                }</span>

                <span class="cov0" title="0">return successMsg("Commit done!")</span>
        }
}

func (m model) createWorkspace(name, desc string) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                id := strings.ToLower(strings.ReplaceAll(name, " ", "-"))
                err := m.wsManager.CreateWorkspace(id, name, desc)
                if err != nil </span><span class="cov0" title="0">{
                        return errMsg(err)
                }</span>
                // Auto-activate the new workspace
                <span class="cov0" title="0">if err := m.wsManager.SetActiveWorkspace(id); err != nil </span><span class="cov0" title="0">{
                        return errMsg(err)
                }</span>
                <span class="cov0" title="0">return successMsg("Workspace created and activated!")</span>
        }
}

func (m model) doApplyHunk(h diff.Hunk, filePath string) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                patch := h.ToPatch(filePath)
                err := m.git.ApplyHunk(context.Background(), patch)
                if err != nil </span><span class="cov0" title="0">{
                        return errMsg(err)
                }</span>
                <span class="cov0" title="0">return successMsg("Hunk applied!")</span>
        }
}

func (m model) doResetHash(target string) tea.Cmd <span class="cov0" title="0">{
        return func() tea.Msg </span><span class="cov0" title="0">{
                err := m.git.ResetToHash(context.Background(), target)
                if err != nil </span><span class="cov0" title="0">{
                        return errMsg(err)
                }</span>
                <span class="cov0" title="0">return successMsg("Repository restored to " + target)</span>
        }
}
</pre>
		
		<pre class="file" id="file1" style="display: none">package main

import (
        "context"
        "tutugit/internal/config"
        "tutugit/internal/git"
        "tutugit/internal/hygiene"
        "tutugit/internal/workspace"

        "github.com/charmbracelet/bubbles/textinput"
)

// initialDemoModel creates a playground state for TUI testing.
func initialDemoModel() model <span class="cov0" title="0">{
        mock := git.NewMockRunner()

        // mock History
        mock.Commits = []git.Commit{
                {Hash: "sha5", ShortHash: "abc555", Message: "feat: add demo mode toggle", Author: "Carlos", Date: "10 mins ago", Email: "carlos@example.com"},
                {Hash: "sha4", ShortHash: "abc444", Message: "wip: incomplete work on styles", Author: "Dev", Date: "1 hour ago", Email: "dev@example.com"},
                {Hash: "sha3", ShortHash: "abc333", Message: "refactor: clean up viewport logic", Author: "Carlos", Date: "5 hours ago", Email: "carlos@example.com"},
                {Hash: "sha2", ShortHash: "abc222", Message: "fix: resolve scary panic in update.go", Author: "John", Date: "1 day ago", Email: "john@example.com"},
                {Hash: "sha1", ShortHash: "abc111", Message: "feat: add super cool workspace grouping", Author: "Carlos", Date: "2 days ago", Email: "carlos@example.com"},
                {Hash: "sha0", ShortHash: "abc000", Message: "chore: initial commit", Author: "Carlos", Date: "1 week ago", Email: "carlos@example.com"},
        }
        mock.ValidHashes = map[string]bool{
                "sha5": true, "sha4": true, "sha3": true, "sha2": true, "sha1": true, "sha0": true,
        }

        // mock Status
        mock.Files = []git.FileStatus{
                {Path: "cmd/tutugit/main.go", Staged: true, Modified: true},
                {Path: "cmd/tutugit/demo.go", Staged: false, Modified: true},
                {Path: "internal/git/mock.go", Staged: false, Modified: true},
                {Path: "internal/git/git.go", Staged: true, Modified: false},
                {Path: "README.md", New: true, Staged: true},
                {Path: "DELETED_FILE.txt", Deleted: true, Staged: false},
                {Path: "untracked_config.json", New: true, Staged: false},
        }
        mock.Status = "M  cmd/tutugit/main.go\n M cmd/tutugit/demo.go\n M internal/git/mock.go\nM  internal/git/git.go\nA  README.md\n D DELETED_FILE.txt\n?? untracked_config.json"
        mock.CurrentBranch = "feature/demo-mode"

        // mock Diffs
        mock.GetDiffFunc = func(ctx context.Context, path string, staged bool) (string, error) </span><span class="cov0" title="0">{
                switch path </span>{
                case "cmd/tutugit/main.go":<span class="cov0" title="0">
                        return "--- a/cmd/tutugit/main.go\n+++ b/cmd/tutugit/main.go\n@@ -10,6 +10,7 @@\n-import \"fmt\"\n+import (\n+    \"fmt\"\n+    \"os\"\n+)", nil</span>
                case "cmd/tutugit/demo.go":<span class="cov0" title="0">
                        return "--- a/cmd/tutugit/demo.go\n+++ b/cmd/tutugit/demo.go\n@@ -1,3 +1,10 @@\n package main\n \n-func demo() {}\n+func initialDemoModel() model {\n+    // magic simulation\n+}", nil</span>
                default:<span class="cov0" title="0">
                        return "diff --git a/" + path + " b/" + path + "\nindex 1234567..890abcd 100644\n--- a/" + path + "\n+++ b/" + path + "\n@@ -1,1 +1,2 @@\n-old content\n+new awesome content\n+another line", nil</span>
                }
        }

        // mock Reflog
        <span class="cov0" title="0">mock.Reflog = []git.ReflogEntry{
                {Hash: "sha5", Selector: "HEAD@{0}", Action: "commit", Message: "feat: add demo mode toggle"},
                {Hash: "sha4", Selector: "HEAD@{1}", Action: "rebase (finish)", Message: "returning to status"},
                {Hash: "sha1", Selector: "HEAD@{2}", Action: "checkout", Message: "from main to feature/demo-mode"},
                {Hash: "sha2", Selector: "HEAD@{3}", Action: "reset", Message: "moving to sha2"},
        }

        // mock Worktrees
        mock.Worktrees = []git.Worktree{
                {Path: "/home/user/tutugit", Branch: "feature/demo-mode", Hash: "sha5", IsMain: true},
                {Path: "/tmp/tutugit-fix", Branch: "hotfix/emergency", Hash: "sha2", IsMain: false},
        }

        // mock Rebase state
        mock.IsRebasingVal = true
        mock.RebaseTodo = []git.RebaseStep{
                {Action: git.ActionPick, Hash: "sha3", Message: "refactor: clean up viewport logic"},
                {Action: git.ActionEdit, Hash: "sha4", Message: "wip: incomplete work on styles"},
                {Action: git.ActionPick, Hash: "sha5", Message: "feat: add demo mode toggle"},
        }

        // mock Workspaces
        meta := &amp;workspace.Meta{
                Version: 1,
                Workspaces: []workspace.Workspace{
                        {ID: "ws1", Name: "UI Refactor", Commits: []string{"sha1", "sha3", "sha5"}},
                        {ID: "ws2", Name: "Bug Hunting", Commits: []string{"sha2"}},
                        {ID: "ws3", Name: "Experiments", Commits: []string{"sha4"}},
                },
                ActiveWorkspace: "ws1",
                Tags: map[string][]string{
                        "sha1": {"feature"},
                        "sha2": {"fix"},
                        "sha3": {"refactor"},
                        "sha5": {"feature"},
                },
                Impacts: map[string]string{
                        "sha5": "minor",
                        "sha4": "patch",
                        "sha1": "major",
                },
        }

        // initialize Inputs and Viewports (reusing styles and defaults)
        // this use a real manager but it won't find files if we point to a temp dir
        w := workspace.NewManager("/tmp/tutugit-demo")

        ti := textinput.New()
        ti.Placeholder = "Demo commit..."
        wn := textinput.New()
        wd := textinput.New()

        vp := newStyledViewport("62")
        hp := newStyledViewport("63")
        rp := newStyledViewport("64")
        sp := newStyledViewport("39")

        return model{
                git:             mock,
                wsManager:       w,
                cfgManager:      nil,
                cfg:             config.DefaultConfig(),
                hygiene:         hygiene.NewAnalyzer(mock, w),
                meta:            meta,
                branch:          "demo-branch",
                files:           mock.Files,
                commits:         mock.Commits,
                reflogEntries:   mock.Reflog,
                worktrees:       mock.Worktrees,
                rebaseSteps:     mock.RebaseTodo,
                isRebasing:      true,
                state:           stateMain,
                commitMsg:       ti,
                newWsName:       wn,
                newWsDesc:       wd,
                expandedFile:    -1,
                diffViewport:    vp,
                historyViewport: hp,
                reflogViewport:  rp,
                summaryViewport: sp,
                expandedHistory: make(map[string]bool),
                isUpdating:      false,
                decidedImpact:   "patch",
        }</span>
}
</pre>
		
		<pre class="file" id="file2" style="display: none">package main

import (
        "fmt"
        "os"
        "tutugit/internal/config"
        "tutugit/internal/workspace"

        tea "github.com/charmbracelet/bubbletea"
)

func (m model) Update(msg tea.Msg) (tea.Model, tea.Cmd) <span class="cov0" title="0">{
        // Dispatch non-KeyMsg messages to handlers
        switch msg := msg.(type) </span>{
        case tea.WindowSizeMsg:<span class="cov0" title="0">
                m.handleWindowResize(msg)
                return m, nil</span>
        case branchMsg:<span class="cov0" title="0">
                m.handleBranchMsg(msg)
                return m, nil</span>
        case filesMsg:<span class="cov0" title="0">
                m.handleFilesMsg(msg)
                return m, nil</span>
        case metaMsg:<span class="cov0" title="0">
                m.handleMetaMsg(msg)
                return m, nil</span>
        case reportMsg:<span class="cov0" title="0">
                m.handleReportMsg(msg)
                return m, nil</span>
        case historyMsg:<span class="cov0" title="0">
                m.handleHistoryMsg(msg)
                return m, nil</span>
        case reflogMsg:<span class="cov0" title="0">
                m.handleReflogMsg(msg)
                return m, nil</span>
        case worktreesMsg:<span class="cov0" title="0">
                m.handleWorktreesMsg(msg)
                return m, nil</span>
        case rebaseStatusMsg:<span class="cov0" title="0">
                m.handleRebaseStatusMsg(msg)
                return m, nil</span>
        case rebaseStepsMsg:<span class="cov0" title="0">
                m.handleRebaseStepsMsg(msg)
                return m, nil</span>
        case summaryMsg:<span class="cov0" title="0">
                m.handleSummaryMsg(msg)
                return m, nil</span>
        case diffMsg:<span class="cov0" title="0">
                m.handleDiffMsg(msg)
                return m, nil</span>
        case successMsg:<span class="cov0" title="0">
                return m.handleSuccessMsg()</span>
        case errMsg:<span class="cov0" title="0">
                m.handleErrorMsg(msg)
                return m, nil</span>
        case tea.KeyMsg:<span class="cov0" title="0">
                // Dispatch KeyMsg to state-specific keyboard handlers
                switch m.state </span>{
                case stateSummary:<span class="cov0" title="0">
                        return m.handleKeySummary(msg)</span>
                case stateReflog:<span class="cov0" title="0">
                        return m.handleKeyReflog(msg)</span>
                case stateReflogConfirm:<span class="cov0" title="0">
                        return m.handleKeyReflogConfirm(msg)</span>
                case stateHistory:<span class="cov0" title="0">
                        return m.handleKeyHistory(msg)</span>
                case stateRebasePrepare:<span class="cov0" title="0">
                        return m.handleKeyRebasePrepare(msg)</span>
                case stateRebaseOngoing:<span class="cov0" title="0">
                        return m.handleKeyRebaseOngoing(msg)</span>
                case stateDiff:<span class="cov0" title="0">
                        return m.handleKeyDiff(msg)</span>
                case stateHunks:<span class="cov0" title="0">
                        return m.handleKeyHunks(msg)</span>
                case stateCommit:<span class="cov0" title="0">
                        return m.handleKeyCommit(msg)</span>
                case stateNewWorkspace:<span class="cov0" title="0">
                        return m.handleKeyNewWorkspace(msg)</span>
                case stateWorkspaces:<span class="cov0" title="0">
                        return m.handleKeyWorkspaces(msg)</span>
                case stateGitWorktrees:<span class="cov0" title="0">
                        return m.handleKeyGitWorktrees(msg)</span>
                case stateMain:<span class="cov0" title="0">
                        return m.handleKeyMain(msg)</span>
                }
        }

        <span class="cov0" title="0">return m, nil</span>
}

func main() <span class="cov0" title="0">{
        if len(os.Args) &gt; 1 </span><span class="cov0" title="0">{
                switch os.Args[1] </span>{
                case "--version":<span class="cov0" title="0">
                        fmt.Printf("tutugit version %s\n", version)
                        return</span>
                case "init":<span class="cov0" title="0">
                        cwd, _ := os.Getwd()
                        wsManager := workspace.NewManager(cwd)
                        cfgManager := config.NewManager(cwd)

                        cfg := config.DefaultConfig()
                        if err := cfgManager.Save(cfg); err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Error saving config: %v\n", err)
                                os.Exit(1)
                        }</span>

                        <span class="cov0" title="0">if err := wsManager.Bootstrap(); err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Error initializing tutugit: %v\n", err)
                                os.Exit(1)
                        }</span>

                        <span class="cov0" title="0">fmt.Println("ðŸš€ tutugit initialized successfully!")
                        fmt.Println(".tutugit directory created with meta.json and config.yml")
                        return</span>
                case "demo":<span class="cov0" title="0">
                        m := initialDemoModel()
                        p := tea.NewProgram(m)
                        if _, err := p.Run(); err != nil </span><span class="cov0" title="0">{
                                fmt.Printf("Error starting demo: %v", err)
                                os.Exit(1)
                        }</span>
                        <span class="cov0" title="0">return</span>
                }
        }

        <span class="cov0" title="0">m, err := initialModel()
        if err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Failed to initialize: %v\n", err)
                os.Exit(1)
        }</span>

        <span class="cov0" title="0">p := tea.NewProgram(m)
        if _, err := p.Run(); err != nil </span><span class="cov0" title="0">{
                fmt.Printf("Error starting tutugit: %v", err)
                os.Exit(1)
        }</span>
}
</pre>
		
		<pre class="file" id="file3" style="display: none">package main

import (
        "fmt"
        "os"

        "tutugit/internal/config"
        "tutugit/internal/diff"
        "tutugit/internal/git"
        "tutugit/internal/hygiene"
        "tutugit/internal/workspace"

        "github.com/charmbracelet/bubbles/textinput"
        "github.com/charmbracelet/bubbles/viewport"
        tea "github.com/charmbracelet/bubbletea"
)

// model represents the application state
type model struct {
        git             git.GitProvider
        wsManager       *workspace.Manager
        cfgManager      *config.Manager
        cfg             *config.Config
        hygiene         *hygiene.Analyzer
        meta            *workspace.Meta
        report          *hygiene.HealthReport
        branch          string
        files           []git.FileStatus
        commits         []git.Commit
        reflogEntries   []git.ReflogEntry
        worktrees       []git.Worktree
        rebaseSteps     []git.RebaseStep
        cursor          int
        expandedFile    int // -1 if none
        fileDiff        string
        hunks           []diff.Hunk
        hunkCursor      int
        historyCursor   int
        reflogCursor    int
        worktreeCursor  int
        rebaseCursor    int
        expandedHistory map[string]bool
        diffViewport    viewport.Model
        historyViewport viewport.Model
        reflogViewport  viewport.Model
        err             error
        state           state
        commitMsg       textinput.Model
        newWsName       textinput.Model
        newWsDesc       textinput.Model
        selectedTag     int
        isUpdating      bool
        isRebasing      bool
        width           int
        height          int
        summaryContent  string
        summaryViewport viewport.Model
        manualImpact    string // empty if auto
        decidedImpact   string // the actual impact being used
        suggestedImpact string
        suggestedCount  int
}

// Message types for tea.Cmd
type branchMsg string
type filesMsg []git.FileStatus
type metaMsg *workspace.Meta
type reportMsg *hygiene.HealthReport
type diffMsg string
type historyMsg []git.Commit
type reflogMsg []git.ReflogEntry
type worktreesMsg []git.Worktree
type rebaseStatusMsg bool
type rebaseStepsMsg []git.RebaseStep
type summaryMsg string
type errMsg error
type successMsg string

// initialModel creates and initializes the application model
func initialModel() (model, error) <span class="cov0" title="0">{
        cwd, err := os.Getwd()
        if err != nil </span><span class="cov0" title="0">{
                return model{}, fmt.Errorf("failed to get working directory: %w", err)
        }</span>
        <span class="cov0" title="0">g := git.NewRunner(cwd)
        w := workspace.NewManager(cwd)
        c := config.NewManager(cwd)

        // Load config (defaults if not present)
        cfg, err := c.Load()
        if err != nil </span><span class="cov0" title="0">{
                cfg = config.DefaultConfig()
        }</span>

        <span class="cov0" title="0">ti := textinput.New()
        ti.Placeholder = "Commit message..."
        ti.Focus()

        wn := textinput.New()
        wn.Placeholder = "Workspace name..."

        wd := textinput.New()
        wd.Placeholder = "Description (optional)..."

        vp := newStyledViewport("62")
        hp := newStyledViewport("63")
        rp := newStyledViewport("64")
        sp := newStyledViewport("39")

        return model{
                git:             g,
                wsManager:       w,
                cfgManager:      c,
                cfg:             cfg,
                hygiene:         hygiene.NewAnalyzer(g, w),
                state:           stateMain,
                commitMsg:       ti,
                newWsName:       wn,
                newWsDesc:       wd,
                expandedFile:    noFileSelected,
                diffViewport:    vp,
                historyViewport: hp,
                reflogViewport:  rp,
                summaryViewport: sp,
                expandedHistory: make(map[string]bool),
                isUpdating:      true,
                decidedImpact:   "patch",
        }, nil</span>
}

func (m model) Init() tea.Cmd <span class="cov0" title="0">{
        return tea.Batch(
                m.fetchBranch,
                m.fetchFiles,
                m.fetchMeta,
                m.fetchHygiene,
                m.fetchRebaseStatus,
        )
}</span>

// View dispatches to the appropriate view based on current state
func (m model) View() string <span class="cov0" title="0">{
        if m.err != nil </span><span class="cov0" title="0">{
                return styleError.Render(fmt.Sprintf("Error: %v", m.err)) + "\n\nPress 'q' to quit."
        }</span>

        <span class="cov0" title="0">switch m.state </span>{
        case stateCommit:<span class="cov0" title="0">
                return m.viewCommit()</span>
        case stateWorkspaces:<span class="cov0" title="0">
                return m.viewWorkspaces()</span>
        case stateNewWorkspace:<span class="cov0" title="0">
                return m.viewNewWorkspace()</span>
        case stateHunks:<span class="cov0" title="0">
                return m.viewHunks()</span>
        case stateDiff:<span class="cov0" title="0">
                return m.viewDiff()</span>
        case stateHistory:<span class="cov0" title="0">
                return m.viewHistory()</span>
        case stateReflog:<span class="cov0" title="0">
                return m.viewReflog()</span>
        case stateReflogConfirm:<span class="cov0" title="0">
                return m.viewReflogConfirm()</span>
        case stateGitWorktrees:<span class="cov0" title="0">
                return m.viewGitWorktrees()</span>
        case stateRebasePrepare:<span class="cov0" title="0">
                return m.viewRebasePrepare()</span>
        case stateRebaseOngoing:<span class="cov0" title="0">
                return m.viewRebaseOngoing()</span>
        case stateSummary:<span class="cov0" title="0">
                return m.viewSummary()</span>
        }

        <span class="cov0" title="0">return m.viewMain()</span>
}
</pre>
		
		<pre class="file" id="file4" style="display: none">package main

import (
        "github.com/charmbracelet/bubbles/viewport"
        "github.com/charmbracelet/lipgloss"
)

var (
        styleTitle = lipgloss.NewStyle().
                        Bold(true).
                        Foreground(lipgloss.Color("#FAFAFA")).
                        Background(lipgloss.Color("#7D56F4")).
                        Padding(0, 1)

        styleBranch = lipgloss.NewStyle().
                        Bold(true).
                        Foreground(lipgloss.Color("#43BF6D"))

        styleSelected = lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#7D56F4")).
                        Bold(true)

        styleStaged = lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#43BF6D"))

        styleUnstaged = lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#E84855"))

        styleWS = lipgloss.NewStyle().
                Foreground(lipgloss.Color("#FAFAFA")).
                Background(lipgloss.Color("#2E3440")).
                Padding(0, 1)

        styleAlert = lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#EAD94C")).
                        Bold(true)

        styleDiffAdd = lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#43BF6D"))

        styleDiffDel = lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#E84855"))

        styleError = lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#E84855"))

        styleDim = lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#666666"))

        styleVersion = lipgloss.NewStyle().
                        Foreground(lipgloss.Color("#7D56F4")).
                        Italic(true)
)

// newStyledViewport creates a new viewport with consistent styling
func newStyledViewport(borderColor string) viewport.Model <span class="cov0" title="0">{
        vp := viewport.New(0, 0)
        vp.Style = lipgloss.NewStyle().
                BorderStyle(lipgloss.RoundedBorder()).
                BorderForeground(lipgloss.Color(borderColor)).
                Padding(0, 1)
        return vp
}</span>
</pre>
		
		<pre class="file" id="file5" style="display: none">package main

import (
        "context"
        "strings"

        "tutugit/internal/diff"
        "tutugit/internal/git"
        "tutugit/internal/workspace"

        tea "github.com/charmbracelet/bubbletea"
)

// handleWindowResize handles terminal window resize events
func (m *model) handleWindowResize(msg tea.WindowSizeMsg) <span class="cov0" title="0">{
        m.width = msg.Width
        m.height = msg.Height
        m.diffViewport.Width = msg.Width
        m.diffViewport.Height = msg.Height - viewportReservedSpace
        m.historyViewport.Height = msg.Height - viewportReservedSpace
        m.historyViewport.Width = msg.Width
        m.reflogViewport.Height = msg.Height - viewportReservedSpace
        m.reflogViewport.Width = msg.Width
        m.summaryViewport.Height = msg.Height - viewportReservedSpace
        m.summaryViewport.Width = msg.Width
}</span>

// handleBranchMsg handles branch name updates
func (m *model) handleBranchMsg(msg branchMsg) <span class="cov0" title="0">{
        m.branch = string(msg)
}</span>

// handleFilesMsg handles file status updates
func (m *model) handleFilesMsg(msg filesMsg) <span class="cov0" title="0">{
        m.files = msg
        m.isUpdating = false
        if m.cursor &gt;= len(m.files) </span><span class="cov0" title="0">{
                m.cursor = len(m.files) - 1
        }</span>
        <span class="cov0" title="0">if m.cursor &lt; 0 &amp;&amp; len(m.files) &gt; 0 </span><span class="cov0" title="0">{
                m.cursor = 0
        }</span>
}

// handleMetaMsg handles workspace metadata updates
func (m *model) handleMetaMsg(msg metaMsg) <span class="cov0" title="0">{
        m.meta = msg
        if m.state == stateNewWorkspace || m.state == stateWorkspaces </span><span class="cov0" title="0">{
                m.state = stateWorkspaces
        }</span>
        <span class="cov0" title="0">m.isUpdating = false</span>
}

// handleReportMsg handles hygiene report updates
func (m *model) handleReportMsg(msg reportMsg) <span class="cov0" title="0">{
        m.report = msg
}</span>

// handleHistoryMsg handles commit history updates
func (m *model) handleHistoryMsg(msg historyMsg) <span class="cov0" title="0">{
        m.commits = msg
        m.isUpdating = false
        m.renderHistory()
}</span>

// handleReflogMsg handles reflog updates
func (m *model) handleReflogMsg(msg reflogMsg) <span class="cov0" title="0">{
        m.reflogEntries = msg
        m.isUpdating = false
        m.renderReflog()
}</span>

// handleWorktreesMsg handles worktree list updates
func (m *model) handleWorktreesMsg(msg worktreesMsg) <span class="cov0" title="0">{
        m.worktrees = msg
        m.isUpdating = false
}</span>

// handleRebaseStatusMsg handles rebase status updates
func (m *model) handleRebaseStatusMsg(msg rebaseStatusMsg) <span class="cov0" title="0">{
        m.isRebasing = bool(msg)
        if m.isRebasing &amp;&amp; m.state == stateMain </span><span class="cov0" title="0">{
                m.state = stateRebaseOngoing
        }</span>
}

// handleRebaseStepsMsg handles rebase step updates
func (m *model) handleRebaseStepsMsg(msg rebaseStepsMsg) <span class="cov0" title="0">{
        m.rebaseSteps = msg
        m.isUpdating = false
        m.state = stateRebasePrepare
        m.rebaseCursor = 0
}</span>

// handleSummaryMsg handles summary content updates
func (m *model) handleSummaryMsg(msg summaryMsg) <span class="cov0" title="0">{
        m.summaryContent = string(msg)
        m.isUpdating = false
        m.state = stateSummary
        m.summaryViewport.SetContent(m.summaryContent)
}</span>

// handleDiffMsg handles diff content updates
func (m *model) handleDiffMsg(msg diffMsg) <span class="cov0" title="0">{
        m.fileDiff = string(msg)
        m.isUpdating = false
        if m.state == stateHunks </span><span class="cov0" title="0">{
                fileDiffs := diff.ParseDiff(m.fileDiff)
                if len(fileDiffs) &gt; 0 </span><span class="cov0" title="0">{
                        m.hunks = fileDiffs[0].Hunks
                        m.hunkCursor = 0
                }</span>
        } else<span class="cov0" title="0"> if m.state == stateDiff </span><span class="cov0" title="0">{
                // Apply styling to diff lines
                lines := strings.Split(m.fileDiff, "\n")
                var styledLines []string
                for _, l := range lines </span><span class="cov0" title="0">{
                        if strings.HasPrefix(l, "+") </span><span class="cov0" title="0">{
                                styledLines = append(styledLines, styleDiffAdd.Render(l))
                        }</span> else<span class="cov0" title="0"> if strings.HasPrefix(l, "-") </span><span class="cov0" title="0">{
                                styledLines = append(styledLines, styleDiffDel.Render(l))
                        }</span> else<span class="cov0" title="0"> {
                                styledLines = append(styledLines, l)
                        }</span>
                }
                <span class="cov0" title="0">m.diffViewport.SetContent(strings.Join(styledLines, "\n"))</span>
        }
}

// handleSuccessMsg handles success messages
func (m *model) handleSuccessMsg() (model, tea.Cmd) <span class="cov0" title="0">{
        if m.state == stateHunks </span><span class="cov0" title="0">{
                // Stay in hunk mode but refresh files/diff
                if m.cursor &gt;= 0 &amp;&amp; m.cursor &lt; len(m.files) </span><span class="cov0" title="0">{
                        f := m.files[m.cursor]
                        return *m, tea.Batch(m.fetchFiles, m.fetchDiff(f.Path, f.Staged), m.fetchHygiene)
                }</span>
        }
        <span class="cov0" title="0">m.state = stateMain
        m.commitMsg.Reset()
        return *m, tea.Batch(m.fetchBranch, m.fetchFiles, m.fetchMeta, m.fetchHygiene)</span>
}

// handleErrorMsg handles error messages
func (m *model) handleErrorMsg(msg errMsg) <span class="cov0" title="0">{
        m.err = msg
        m.isUpdating = false
}</span>

// handleKeySummary handles keyboard input in summary view state
func (m *model) handleKeySummary(msg tea.KeyMsg) (model, tea.Cmd) <span class="cov0" title="0">{
        switch msg.String() </span>{
        case "esc", "q", "L":<span class="cov0" title="0">
                m.state = stateMain
                return *m, nil</span>
        case "E":<span class="cov0" title="0">
                if !m.isUpdating </span><span class="cov0" title="0">{
                        m.isUpdating = true
                        return *m, m.exportMarkdown()
                }</span>
        }
        <span class="cov0" title="0">var cmd tea.Cmd
        m.summaryViewport, cmd = m.summaryViewport.Update(msg)
        return *m, cmd</span>
}

// handleKeyReflog handles keyboard input in reflog state
func (m *model) handleKeyReflog(msg tea.KeyMsg) (model, tea.Cmd) <span class="cov0" title="0">{
        switch msg.String() </span>{
        case "esc", "q", "g":<span class="cov0" title="0">
                m.state = stateMain
                return *m, nil</span>
        case "up", "k":<span class="cov0" title="0">
                if m.reflogCursor &gt; 0 </span><span class="cov0" title="0">{
                        m.reflogCursor--
                        m.renderReflog()
                }</span>
        case "down", "j":<span class="cov0" title="0">
                if m.reflogCursor &lt; len(m.reflogEntries)-1 </span><span class="cov0" title="0">{
                        m.reflogCursor++
                        m.renderReflog()
                }</span>
        case "enter":<span class="cov0" title="0">
                if len(m.reflogEntries) &gt; 0 </span><span class="cov0" title="0">{
                        m.state = stateReflogConfirm
                        return *m, nil
                }</span>
        }
        <span class="cov0" title="0">var cmd tea.Cmd
        m.reflogViewport, cmd = m.reflogViewport.Update(msg)
        return *m, cmd</span>
}

// handleKeyReflogConfirm handles keyboard input in reflog confirmation state
func (m *model) handleKeyReflogConfirm(msg tea.KeyMsg) (model, tea.Cmd) <span class="cov0" title="0">{
        switch msg.String() </span>{
        case "esc", "n":<span class="cov0" title="0">
                m.state = stateReflog
                return *m, nil</span>
        case "y", "enter":<span class="cov0" title="0">
                if m.reflogCursor &gt;= 0 &amp;&amp; m.reflogCursor &lt; len(m.reflogEntries) </span><span class="cov0" title="0">{
                        m.isUpdating = true
                        entry := m.reflogEntries[m.reflogCursor]
                        return *m, m.doResetHash(entry.Selector)
                }</span>
        }
        <span class="cov0" title="0">return *m, nil</span>
}

// handleKeyHistory handles keyboard input in history state
func (m *model) handleKeyHistory(msg tea.KeyMsg) (model, tea.Cmd) <span class="cov0" title="0">{
        switch msg.String() </span>{
        case "esc", "q", "h":<span class="cov0" title="0">
                m.state = stateMain
                return *m, nil</span>
        case "R":<span class="cov0" title="0">
                if m.historyCursor &gt;= 0 &amp;&amp; m.historyCursor &lt; len(m.commits) </span><span class="cov0" title="0">{
                        hash := m.commits[m.historyCursor].Hash
                        m.isUpdating = true
                        return *m, m.fetchRebaseSteps(hash)
                }</span>
        case "up", "k":<span class="cov0" title="0">
                if m.historyCursor &gt; 0 </span><span class="cov0" title="0">{
                        m.historyCursor--
                        m.renderHistory()
                }</span>
                <span class="cov0" title="0">return *m, nil</span>
        case "down", "j":<span class="cov0" title="0">
                if m.historyCursor &lt; len(m.commits)-1 </span><span class="cov0" title="0">{
                        m.historyCursor++
                        m.renderHistory()
                }</span>
                <span class="cov0" title="0">return *m, nil</span>
        case "enter":<span class="cov0" title="0">
                if m.historyCursor &gt;= 0 &amp;&amp; m.historyCursor &lt; len(m.commits) </span><span class="cov0" title="0">{
                        hash := m.commits[m.historyCursor].Hash
                        m.expandedHistory[hash] = !m.expandedHistory[hash]
                        m.renderHistory()
                }</span>
                <span class="cov0" title="0">return *m, nil</span>
        case "L":<span class="cov0" title="0">
                m.isUpdating = true
                m.summaryViewport.SetContent("Generating summary...")
                return *m, m.fetchSummary()</span>
        }
        <span class="cov0" title="0">var cmd tea.Cmd
        m.historyViewport, cmd = m.historyViewport.Update(msg)
        return *m, cmd</span>
}

// handleKeyRebasePrepare handles keyboard input in rebase prepare state
func (m *model) handleKeyRebasePrepare(msg tea.KeyMsg) (model, tea.Cmd) <span class="cov0" title="0">{
        switch msg.String() </span>{
        case "esc", "q":<span class="cov0" title="0">
                m.state = stateHistory
                return *m, nil</span>
        case "up", "k":<span class="cov0" title="0">
                if m.rebaseCursor &gt; 0 </span><span class="cov0" title="0">{
                        m.rebaseCursor--
                }</span>
        case "down", "j":<span class="cov0" title="0">
                if m.rebaseCursor &lt; len(m.rebaseSteps)-1 </span><span class="cov0" title="0">{
                        m.rebaseCursor++
                }</span>
        case "K":<span class="cov0" title="0"> // Move up
                if m.rebaseCursor &gt; 0 </span><span class="cov0" title="0">{
                        m.rebaseSteps[m.rebaseCursor], m.rebaseSteps[m.rebaseCursor-1] = m.rebaseSteps[m.rebaseCursor-1], m.rebaseSteps[m.rebaseCursor]
                        m.rebaseCursor--
                }</span>
        case "J":<span class="cov0" title="0"> // Move down
                if m.rebaseCursor &lt; len(m.rebaseSteps)-1 </span><span class="cov0" title="0">{
                        m.rebaseSteps[m.rebaseCursor], m.rebaseSteps[m.rebaseCursor+1] = m.rebaseSteps[m.rebaseCursor+1], m.rebaseSteps[m.rebaseCursor]
                        m.rebaseCursor++
                }</span>
        case "p":<span class="cov0" title="0">
                if m.rebaseCursor &gt;= 0 &amp;&amp; m.rebaseCursor &lt; len(m.rebaseSteps) </span><span class="cov0" title="0">{
                        m.rebaseSteps[m.rebaseCursor].Action = git.ActionPick
                }</span>
        case "s":<span class="cov0" title="0">
                if m.rebaseCursor &gt;= 0 &amp;&amp; m.rebaseCursor &lt; len(m.rebaseSteps) </span><span class="cov0" title="0">{
                        m.rebaseSteps[m.rebaseCursor].Action = git.ActionSquash
                }</span>
        case "f":<span class="cov0" title="0">
                if m.rebaseCursor &gt;= 0 &amp;&amp; m.rebaseCursor &lt; len(m.rebaseSteps) </span><span class="cov0" title="0">{
                        m.rebaseSteps[m.rebaseCursor].Action = git.ActionFixup
                }</span>
        case "e":<span class="cov0" title="0">
                if m.rebaseCursor &gt;= 0 &amp;&amp; m.rebaseCursor &lt; len(m.rebaseSteps) </span><span class="cov0" title="0">{
                        m.rebaseSteps[m.rebaseCursor].Action = git.ActionEdit
                }</span>
        case "d":<span class="cov0" title="0">
                if m.rebaseCursor &gt;= 0 &amp;&amp; m.rebaseCursor &lt; len(m.rebaseSteps) </span><span class="cov0" title="0">{
                        m.rebaseSteps[m.rebaseCursor].Action = git.ActionDrop
                }</span>
        case "r":<span class="cov0" title="0">
                if m.rebaseCursor &gt;= 0 &amp;&amp; m.rebaseCursor &lt; len(m.rebaseSteps) </span><span class="cov0" title="0">{
                        m.rebaseSteps[m.rebaseCursor].Action = git.ActionReword
                }</span>
        case "enter":<span class="cov0" title="0">
                if m.historyCursor &gt;= 0 &amp;&amp; m.historyCursor &lt; len(m.commits) &amp;&amp; len(m.rebaseSteps) &gt; 0 </span><span class="cov0" title="0">{
                        m.isUpdating = true
                        base := m.commits[m.historyCursor].Hash
                        return *m, func() tea.Msg </span><span class="cov0" title="0">{
                                err := m.git.RunInteractiveRebase(context.Background(), base, m.rebaseSteps)
                                if err != nil </span><span class="cov0" title="0">{
                                        return errMsg(err)
                                }</span>
                                <span class="cov0" title="0">return successMsg("Rebase completed successfully!")</span>
                        }
                }
        }
        <span class="cov0" title="0">return *m, nil</span>
}

// handleKeyRebaseOngoing handles keyboard input in rebase ongoing state
func (m *model) handleKeyRebaseOngoing(msg tea.KeyMsg) (model, tea.Cmd) <span class="cov0" title="0">{
        switch msg.String() </span>{
        case "c":<span class="cov0" title="0">
                m.isUpdating = true
                return *m, func() tea.Msg </span><span class="cov0" title="0">{
                        err := m.git.RebaseContinue(context.Background())
                        if err != nil </span><span class="cov0" title="0">{
                                return errMsg(err)
                        }</span>
                        <span class="cov0" title="0">return successMsg("Rebase continued!")</span>
                }
        case "a":<span class="cov0" title="0">
                m.isUpdating = true
                return *m, func() tea.Msg </span><span class="cov0" title="0">{
                        err := m.git.RebaseAbort(context.Background())
                        if err != nil </span><span class="cov0" title="0">{
                                return errMsg(err)
                        }</span>
                        <span class="cov0" title="0">return successMsg("Rebase aborted!")</span>
                }
        case "s":<span class="cov0" title="0">
                m.isUpdating = true
                return *m, func() tea.Msg </span><span class="cov0" title="0">{
                        err := m.git.RebaseSkip(context.Background())
                        if err != nil </span><span class="cov0" title="0">{
                                return errMsg(err)
                        }</span>
                        <span class="cov0" title="0">return successMsg("Patch skipped!")</span>
                }
        case "esc", "q":<span class="cov0" title="0">
                m.state = stateMain
                return *m, nil</span>
        }
        <span class="cov0" title="0">return *m, nil</span>
}

// handleKeyDiff handles keyboard input in diff view state
func (m *model) handleKeyDiff(msg tea.KeyMsg) (model, tea.Cmd) <span class="cov0" title="0">{
        switch msg.String() </span>{
        case "esc", "q", "d":<span class="cov0" title="0">
                m.state = stateMain
                return *m, nil</span>
        }
        <span class="cov0" title="0">var cmd tea.Cmd
        m.diffViewport, cmd = m.diffViewport.Update(msg)
        return *m, cmd</span>
}

// handleKeyHunks handles keyboard input in hunks state
func (m *model) handleKeyHunks(msg tea.KeyMsg) (model, tea.Cmd) <span class="cov0" title="0">{
        switch msg.String() </span>{
        case "esc", "q":<span class="cov0" title="0">
                m.state = stateMain
                m.hunks = nil
                return *m, nil</span>
        case "up", "k":<span class="cov0" title="0">
                if m.hunkCursor &gt; 0 </span><span class="cov0" title="0">{
                        m.hunkCursor--
                }</span>
        case "down", "j":<span class="cov0" title="0">
                if m.hunkCursor &lt; len(m.hunks)-1 </span><span class="cov0" title="0">{
                        m.hunkCursor++
                }</span>
        case "space", "s":<span class="cov0" title="0">
                if m.hunkCursor &gt;= 0 &amp;&amp; m.hunkCursor &lt; len(m.hunks) &amp;&amp;
                        m.cursor &gt;= 0 &amp;&amp; m.cursor &lt; len(m.files) </span><span class="cov0" title="0">{
                        m.isUpdating = true
                        f := m.files[m.cursor]
                        return *m, m.doApplyHunk(m.hunks[m.hunkCursor], f.Path)
                }</span>
        }
        <span class="cov0" title="0">return *m, nil</span>
}

// handleKeyCommit handles keyboard input in commit state
func (m *model) handleKeyCommit(msg tea.KeyMsg) (model, tea.Cmd) <span class="cov0" title="0">{
        switch msg.String() </span>{
        case "esc":<span class="cov0" title="0">
                m.state = stateMain
                return *m, nil</span>
        case "alt+i":<span class="cov0" title="0">
                // Cycle impact: patch -&gt; minor -&gt; major -&gt; "" (auto)
                switch m.manualImpact </span>{
                case "":<span class="cov0" title="0">
                        m.manualImpact = "patch"</span>
                case "patch":<span class="cov0" title="0">
                        m.manualImpact = "minor"</span>
                case "minor":<span class="cov0" title="0">
                        m.manualImpact = "major"</span>
                case "major":<span class="cov0" title="0">
                        m.manualImpact = ""</span> // back to auto
                }
                <span class="cov0" title="0">m.decidedImpact = m.manualImpact
                if m.manualImpact == "" </span><span class="cov0" title="0">{
                        m.decidedImpact = workspace.DetectImpact(m.commitMsg.Value())
                }</span>
                <span class="cov0" title="0">return *m, nil</span>
        case "enter":<span class="cov0" title="0">
                if m.commitMsg.Value() != "" </span><span class="cov0" title="0">{
                        m.isUpdating = true
                        return *m, m.doCommit(m.commitMsg.Value())
                }</span>
        }

        <span class="cov0" title="0">oldVal := m.commitMsg.Value()
        var cmd tea.Cmd
        m.commitMsg, cmd = m.commitMsg.Update(msg)
        newVal := m.commitMsg.Value()

        // update impact if NOT manual and message changed
        if m.manualImpact == "" &amp;&amp; oldVal != newVal </span><span class="cov0" title="0">{
                m.decidedImpact = workspace.DetectImpact(newVal)
        }</span>
        <span class="cov0" title="0">return *m, cmd</span>
}

// handleKeyNewWorkspace handles keyboard input in new workspace state
func (m *model) handleKeyNewWorkspace(msg tea.KeyMsg) (model, tea.Cmd) <span class="cov0" title="0">{
        switch msg.String() </span>{
        case "esc":<span class="cov0" title="0">
                m.state = stateWorkspaces
                return *m, nil</span>
        case "tab":<span class="cov0" title="0">
                if m.newWsName.Focused() </span><span class="cov0" title="0">{
                        m.newWsName.Blur()
                        m.newWsDesc.Focus()
                }</span> else<span class="cov0" title="0"> {
                        m.newWsDesc.Blur()
                        m.newWsName.Focus()
                }</span>
                <span class="cov0" title="0">return *m, nil</span>
        case "enter":<span class="cov0" title="0">
                if m.newWsName.Value() != "" </span><span class="cov0" title="0">{
                        m.isUpdating = true
                        return *m, m.createWorkspace(m.newWsName.Value(), m.newWsDesc.Value())
                }</span>
        }
        <span class="cov0" title="0">var cmd tea.Cmd
        if m.newWsName.Focused() </span><span class="cov0" title="0">{
                m.newWsName, cmd = m.newWsName.Update(msg)
        }</span> else<span class="cov0" title="0"> {
                m.newWsDesc, cmd = m.newWsDesc.Update(msg)
        }</span>
        <span class="cov0" title="0">return *m, cmd</span>
}

// handleKeyWorkspaces handles keyboard input in workspaces state
func (m *model) handleKeyWorkspaces(msg tea.KeyMsg) (model, tea.Cmd) <span class="cov0" title="0">{
        switch msg.String() </span>{
        case "esc", "w":<span class="cov0" title="0">
                m.state = stateMain
                m.cursor = 0</span>
        case "up", "k":<span class="cov0" title="0">
                if m.cursor &gt; 0 </span><span class="cov0" title="0">{
                        m.cursor--
                }</span>
        case "down", "j":<span class="cov0" title="0">
                if m.cursor &lt; len(m.meta.Workspaces)-1 </span><span class="cov0" title="0">{
                        m.cursor++
                }</span>
        case "n":<span class="cov0" title="0">
                m.state = stateNewWorkspace
                m.newWsName.Reset()
                m.newWsDesc.Reset()
                m.newWsName.Focus()</span>
        case "a":<span class="cov0" title="0">
                if m.meta != nil &amp;&amp; len(m.meta.Workspaces) &gt; 0 &amp;&amp; m.cursor &lt; len(m.meta.Workspaces) </span><span class="cov0" title="0">{
                        wsID := m.meta.Workspaces[m.cursor].ID
                        m.isUpdating = true
                        return *m, func() tea.Msg </span><span class="cov0" title="0">{
                                if err := m.wsManager.SetActiveWorkspace(wsID); err != nil </span><span class="cov0" title="0">{
                                        return errMsg(err)
                                }</span>
                                <span class="cov0" title="0">return successMsg("Workspace activated!")</span>
                        }
                }
        }
        <span class="cov0" title="0">return *m, nil</span>
}

// handleKeyGitWorktrees handles keyboard input in git worktrees state
func (m *model) handleKeyGitWorktrees(msg tea.KeyMsg) (model, tea.Cmd) <span class="cov0" title="0">{
        switch msg.String() </span>{
        case "esc", "q", "t":<span class="cov0" title="0">
                m.state = stateMain
                return *m, nil</span>
        case "up", "k":<span class="cov0" title="0">
                if m.worktreeCursor &gt; 0 </span><span class="cov0" title="0">{
                        m.worktreeCursor--
                }</span>
        case "down", "j":<span class="cov0" title="0">
                if m.worktreeCursor &lt; len(m.worktrees)-1 </span><span class="cov0" title="0">{
                        m.worktreeCursor++
                }</span>
        }
        <span class="cov0" title="0">return *m, nil</span>
}

// handleKeyMain handles keyboard input in main state
func (m *model) handleKeyMain(msg tea.KeyMsg) (model, tea.Cmd) <span class="cov0" title="0">{
        switch msg.String() </span>{
        case "q", "ctrl+c":<span class="cov0" title="0">
                return *m, tea.Quit</span>
        case "r":<span class="cov0" title="0">
                m.isUpdating = true
                return *m, tea.Batch(m.fetchBranch, m.fetchFiles, m.fetchMeta, m.fetchHygiene)</span>
        case "up", "k":<span class="cov0" title="0">
                if m.cursor &gt; 0 </span><span class="cov0" title="0">{
                        m.cursor--
                }</span>
        case "down", "j":<span class="cov0" title="0">
                if m.cursor &lt; len(m.files)-1 </span><span class="cov0" title="0">{
                        m.cursor++
                }</span>
        case "space", "s":<span class="cov0" title="0">
                if m.cursor &gt;= 0 &amp;&amp; m.cursor &lt; len(m.files) </span><span class="cov0" title="0">{
                        f := m.files[m.cursor]
                        m.isUpdating = true
                        return *m, m.toggleStage(f)
                }</span>
        case "enter", "e":<span class="cov0" title="0">
                if m.cursor &gt;= 0 &amp;&amp; m.cursor &lt; len(m.files) </span><span class="cov0" title="0">{
                        if m.expandedFile == m.cursor </span><span class="cov0" title="0">{
                                m.expandedFile = -1
                                m.fileDiff = ""
                        }</span> else<span class="cov0" title="0"> {
                                m.expandedFile = m.cursor
                                m.isUpdating = true
                                f := m.files[m.cursor]
                                return *m, m.fetchDiff(f.Path, f.Staged)
                        }</span>
                }
        case "d":<span class="cov0" title="0">
                if m.cursor &gt;= 0 &amp;&amp; m.cursor &lt; len(m.files) </span><span class="cov0" title="0">{
                        m.state = stateDiff
                        m.isUpdating = true
                        f := m.files[m.cursor]
                        m.diffViewport.SetContent("Loading diff...")
                        return *m, m.fetchDiff(f.Path, f.Staged)
                }</span>
        case "h":<span class="cov0" title="0">
                m.state = stateHistory
                m.isUpdating = true
                m.historyViewport.SetContent("Loading history...")
                return *m, m.fetchHistory</span>
        case "g":<span class="cov0" title="0">
                m.state = stateReflog
                m.isUpdating = true
                m.reflogViewport.SetContent("Loading reflog...")
                return *m, m.fetchReflog</span>
        case "t":<span class="cov0" title="0">
                m.state = stateGitWorktrees
                m.isUpdating = true
                return *m, m.fetchWorktrees</span>
        case "p":<span class="cov0" title="0">
                if len(m.files) &gt; 0 </span><span class="cov0" title="0">{
                        m.state = stateHunks
                        m.isUpdating = true
                        f := m.files[m.cursor]
                        return *m, m.fetchDiff(f.Path, f.Staged)
                }</span>
        case "c":<span class="cov0" title="0">
                m.state = stateCommit
                m.commitMsg.Focus()</span>
        case "w":<span class="cov0" title="0">
                m.state = stateWorkspaces
                m.cursor = 0</span>
        case "L":<span class="cov0" title="0">
                m.isUpdating = true
                m.summaryViewport.SetContent("Generating summary...")
                return *m, m.fetchSummary()</span>
        }
        <span class="cov0" title="0">return *m, nil</span>
}
</pre>
		
		<pre class="file" id="file6" style="display: none">package main

import (
        "fmt"
        "strings"

        "tutugit/internal/git"
        "tutugit/internal/workspace"

        "github.com/charmbracelet/lipgloss"
)

func (m model) viewRebasePrepare() string <span class="cov0" title="0">{
        s := m.renderHeader()
        s += styleTitle.Render(" Interactive Rebase Planner ") + "\n\n"
        s += "Reorder and select actions for the commits:\n\n"

        for i, step := range m.rebaseSteps </span><span class="cov0" title="0">{
                cursor := "  "
                if m.rebaseCursor == i </span><span class="cov0" title="0">{
                        cursor = "â¯ "
                }</span>

                <span class="cov0" title="0">actionStyle := styleSelected
                switch step.Action </span>{
                case git.ActionPick:<span class="cov0" title="0">
                        actionStyle = styleStaged</span>
                case git.ActionDrop:<span class="cov0" title="0">
                        actionStyle = styleUnstaged</span>
                case git.ActionSquash, git.ActionFixup:<span class="cov0" title="0">
                        actionStyle = styleAlert</span>
                }

                <span class="cov0" title="0">line := fmt.Sprintf("%-7s %s %s",
                        actionStyle.Render(string(step.Action)),
                        styleSelected.Render(step.Hash[:7]),
                        step.Message)

                if m.rebaseCursor == i </span><span class="cov0" title="0">{
                        s += cursor + styleSelected.Render(line) + "\n"
                }</span> else<span class="cov0" title="0"> {
                        s += cursor + line + "\n"
                }</span>
        }

        <span class="cov0" title="0">s += "\nShortcuts: [j/k] navigate | [p/s/f/e/d/r] actions | [J/K] move | [enter] start | [esc] cancel\n"
        return s</span>
}

func (m model) viewRebaseOngoing() string <span class="cov0" title="0">{
        s := m.renderHeader()
        s += styleTitle.Render(" Rebase in Progress ") + "\n\n"
        s += styleAlert.Render("âš ï¸  The Git is in the middle of a rebase.") + "\n"
        s += "Resolve the conflicts in the files if necessary.\n\n"
        s += "Shortcuts:\n"
        s += "  [c] Continue  - Continue after resolving conflicts\n"
        s += "  [s] Skip      - Skip the current patch\n"
        s += "  [a] Abort     - Abort the rebase\n"
        s += "  [esc/q]       - Back to main screen\n"
        return s
}</span>

func (m model) viewGitWorktrees() string <span class="cov0" title="0">{
        s := m.renderHeader()
        s += styleTitle.Render(" Worktree Explorer ") + "\n\n"

        if len(m.worktrees) == 0 </span><span class="cov0" title="0">{
                if m.isUpdating </span><span class="cov0" title="0">{
                        s += "  Loading worktrees...\n"
                }</span> else<span class="cov0" title="0"> {
                        s += "  No worktrees (only main).\n"
                }</span>
        } else<span class="cov0" title="0"> {
                for i, wt := range m.worktrees </span><span class="cov0" title="0">{
                        cursor := "  "
                        if m.worktreeCursor == i </span><span class="cov0" title="0">{
                                cursor = "â¯ "
                        }</span>

                        <span class="cov0" title="0">style := lipgloss.NewStyle()
                        if wt.IsMain </span><span class="cov0" title="0">{
                                style = styleBranch.Copy().Bold(true)
                        }</span>

                        <span class="cov0" title="0">line := fmt.Sprintf("%s%s [%s] in %s",
                                cursor,
                                style.Render(wt.Branch),
                                styleSelected.Render(wt.Hash[:7]),
                                wt.Path)

                        if m.worktreeCursor == i </span><span class="cov0" title="0">{
                                s += styleSelected.Render(line) + "\n"
                        }</span> else<span class="cov0" title="0"> {
                                s += line + "\n"
                        }</span>
                }
        }

        <span class="cov0" title="0">s += "\nShortcuts: [j/k/up/down] navigate | [esc/q/t] back\n"
        return s</span>
}

func (m model) viewReflogConfirm() string <span class="cov0" title="0">{
        if m.reflogCursor &lt; 0 || m.reflogCursor &gt;= len(m.reflogEntries) </span><span class="cov0" title="0">{
                return styleError.Render("Invalid reflog entry selected")
        }</span>
        <span class="cov0" title="0">entry := m.reflogEntries[m.reflogCursor]
        s := styleTitle.Render(" WARNING: Restore Repository? ") + "\n\n"
        s += "You are about to perform a " + styleError.Render("RESET --HARD") + "\n"
        s += "to the state: " + styleSelected.Render(entry.Selector) + "\n"
        s += "Original action: " + styleAlert.Render(entry.Action) + "\n"
        s += "Message: " + entry.Message + "\n\n"
        s += styleError.Render("âš ï¸  THIS WILL OVERWRITE ALL UNCOMMITTED CHANGES!") + "\n\n"
        s += "Do you want to continue? [y] Yes / [n] No (Esc to cancel)\n"
        return s</span>
}

func (m model) viewDiff() string <span class="cov0" title="0">{
        if m.cursor &lt; 0 || m.cursor &gt;= len(m.files) </span><span class="cov0" title="0">{
                return styleError.Render("No file selected")
        }</span>
        <span class="cov0" title="0">f := m.files[m.cursor]
        s := m.renderHeader()
        s += styleTitle.Render(" Diff Full: "+f.Path) + " "
        if f.Staged </span><span class="cov0" title="0">{
                s += styleStaged.Render("[STAGED]")
        }</span> else<span class="cov0" title="0"> {
                s += styleUnstaged.Render("[UNSTAGED]")
        }</span>

        <span class="cov0" title="0">help := "\nShortcuts: [j/k/up/down] scroll | [esc/q/d] back | [s] toggle stage\n"
        return s + "\n" + m.diffViewport.View() + help</span>
}

func (m model) viewHunks() string <span class="cov0" title="0">{
        if m.cursor &lt; 0 || m.cursor &gt;= len(m.files) </span><span class="cov0" title="0">{
                return styleError.Render("No file selected")
        }</span>
        <span class="cov0" title="0">f := m.files[m.cursor]
        s := m.renderHeader()
        s += styleTitle.Render(" Surgical Staging: "+f.Path) + "\n\n"

        if len(m.hunks) == 0 </span><span class="cov0" title="0">{
                if m.isUpdating </span><span class="cov0" title="0">{
                        s += "  Loading hunks...\n"
                }</span> else<span class="cov0" title="0"> {
                        s += "  No hunks detected.\n"
                }</span>
        } else<span class="cov0" title="0"> {
                for i, h := range m.hunks </span><span class="cov0" title="0">{
                        cursor := "  "
                        if m.hunkCursor == i </span><span class="cov0" title="0">{
                                cursor = "&gt; "
                        }</span>

                        <span class="cov0" title="0">header := styleWS.Render(fmt.Sprintf("Hunk %d/%d", i+1, len(m.hunks)))
                        if m.hunkCursor == i </span><span class="cov0" title="0">{
                                s += cursor + styleSelected.Render(header) + "\n"
                                // show hunk content for selected
                                lines := strings.Split(h.Content, "\n")
                                for _, l := range lines </span><span class="cov0" title="0">{
                                        if strings.HasPrefix(l, "+") </span><span class="cov0" title="0">{
                                                s += styleDiffAdd.Render("    "+l) + "\n"
                                        }</span> else<span class="cov0" title="0"> if strings.HasPrefix(l, "-") </span><span class="cov0" title="0">{
                                                s += styleDiffDel.Render("    "+l) + "\n"
                                        }</span> else<span class="cov0" title="0"> {
                                                s += "    " + l + "\n"
                                        }</span>
                                }
                                <span class="cov0" title="0">s += "\n"</span>
                        } else<span class="cov0" title="0"> {
                                s += cursor + header + "\n"
                        }</span>
                }
        }

        <span class="cov0" title="0">s += "\nShortcuts: [j/k] navigate | [space/s] stage hunk | [esc/q] back\n"
        return s</span>
}

func (m model) renderHeader() string <span class="cov0" title="0">{
        appName := styleTitle.Render(" tutugit ")
        vTag := styleVersion.Render(" v" + version)
        branch := styleBranch.Render(" " + m.branch)

        header := appName + vTag + branch
        if m.isUpdating </span><span class="cov0" title="0">{
                header += styleDim.Render(" (updating...)")
        }</span>

        // add project info if present
        <span class="cov0" title="0">if m.cfg != nil &amp;&amp; m.cfg.Project.Name != "" </span><span class="cov0" title="0">{
                header += "\n" + styleWS.Render(" "+m.cfg.Project.Name+" ")
                if m.cfg.Project.Description != "" </span><span class="cov0" title="0">{
                        header += " " + styleDim.Render(m.cfg.Project.Description)
                }</span>
        }

        <span class="cov0" title="0">return header + "\n\n"</span>
}

func (m model) viewMain() string <span class="cov0" title="0">{
        s := m.renderHeader()

        // hygiene alerts section
        if m.report != nil </span><span class="cov0" title="0">{
                alerts := []string{}
                if len(m.report.WIPCommits) &gt; 0 </span><span class="cov0" title="0">{
                        alerts = append(alerts, fmt.Sprintf("! Detected %d WIP commits in history", len(m.report.WIPCommits)))
                }</span>
                <span class="cov0" title="0">if len(m.report.SquashSuggestions) &gt; 0 </span><span class="cov0" title="0">{
                        alerts = append(alerts, fmt.Sprintf("! Workspaces suggested for squash: %s", strings.Join(m.report.SquashSuggestions, ", ")))
                }</span>
                <span class="cov0" title="0">if len(m.report.StaleWorkspaces) &gt; 0 </span><span class="cov0" title="0">{
                        alerts = append(alerts, fmt.Sprintf("! Workspaces with invalid commits (stale): %s", strings.Join(m.report.StaleWorkspaces, ", ")))
                }</span>

                <span class="cov0" title="0">if len(alerts) &gt; 0 </span><span class="cov0" title="0">{
                        s += "Hygiene Alerts:\n"
                        for _, a := range alerts </span><span class="cov0" title="0">{
                                s += styleAlert.Render("  "+a) + "\n"
                        }</span>
                        <span class="cov0" title="0">s += "\n"</span>
                }
        }

        <span class="cov0" title="0">s += "Git Status:\n"

        if len(m.files) == 0 </span><span class="cov0" title="0">{
                s += "  No pending changes\n"
        }</span>

        <span class="cov0" title="0">for i, f := range m.files </span><span class="cov0" title="0">{
                cursor := "  "
                if m.cursor == i </span><span class="cov0" title="0">{
                        cursor = "&gt; "
                }</span>

                <span class="cov0" title="0">statusChar := "U"
                stagedStyle := styleUnstaged
                if f.Staged </span><span class="cov0" title="0">{
                        statusChar = "S"
                        stagedStyle = styleStaged
                }</span>

                <span class="cov0" title="0">line := fmt.Sprintf("%s [%s] %s", cursor, statusChar, f.Path)
                if m.cursor == i </span><span class="cov0" title="0">{
                        s += styleSelected.Render(line) + "\n"
                }</span> else<span class="cov0" title="0"> {
                        s += stagedStyle.Render(line) + "\n"
                }</span>

                // inline diff if expanded
                <span class="cov0" title="0">if m.expandedFile == i </span><span class="cov0" title="0">{
                        if m.fileDiff == "" &amp;&amp; m.isUpdating </span><span class="cov0" title="0">{
                                s += "    Loading diff...\n"
                        }</span> else<span class="cov0" title="0"> if m.fileDiff == "" </span><span class="cov0" title="0">{
                                s += "    (no changes to show)\n"
                        }</span> else<span class="cov0" title="0"> {
                                diffLines := strings.Split(m.fileDiff, "\n")
                                // limit lines for preview
                                displayLines := 10
                                if len(diffLines) &lt; displayLines </span><span class="cov0" title="0">{
                                        displayLines = len(diffLines)
                                }</span>
                                <span class="cov0" title="0">for _, dl := range diffLines[:displayLines] </span><span class="cov0" title="0">{
                                        if strings.HasPrefix(dl, "+") </span><span class="cov0" title="0">{
                                                s += styleDiffAdd.Render("    "+dl) + "\n"
                                        }</span> else<span class="cov0" title="0"> if strings.HasPrefix(dl, "-") </span><span class="cov0" title="0">{
                                                s += styleDiffDel.Render("    "+dl) + "\n"
                                        }</span> else<span class="cov0" title="0"> {
                                                s += "    " + dl + "\n"
                                        }</span>
                                }
                                <span class="cov0" title="0">if len(diffLines) &gt; displayLines </span><span class="cov0" title="0">{
                                        s += fmt.Sprintf("    ... (+%d lines)\n", len(diffLines)-displayLines)
                                }</span>
                        }
                }
        }

        <span class="cov0" title="0">s += "\nShortcuts: [q] quit | [r] refresh | [space] stage | [c] commit | [e/enter] diff | [d] full diff | [h] history | [g] reflog | [t] worktrees | [w] workspaces | [L] summary\n"

        return s</span>
}

func (m *model) renderReflog() <span class="cov0" title="0">{
        var b strings.Builder
        for i, e := range m.reflogEntries </span><span class="cov0" title="0">{
                prefix := "  "
                if m.reflogCursor == i </span><span class="cov0" title="0">{
                        prefix = "â¯ "
                }</span>

                <span class="cov0" title="0">color := "240"
                switch strings.ToLower(e.Action) </span>{
                case "commit":<span class="cov0" title="0">
                        color = "#43BF6D"</span>
                case "rebase":<span class="cov0" title="0">
                        color = "#7D56F4"</span>
                case "reset":<span class="cov0" title="0">
                        color = "#E84855"</span>
                case "checkout":<span class="cov0" title="0">
                        color = "#FAFAFA"</span>
                }

                <span class="cov0" title="0">line := fmt.Sprintf("%s%s [%s] %s: %s",
                        prefix,
                        lipgloss.NewStyle().Foreground(lipgloss.Color(color)).Bold(true).Render(e.Selector),
                        styleSelected.Render(e.Hash[:7]),
                        styleAlert.Render(e.Action),
                        e.Message)

                if m.reflogCursor == i </span><span class="cov0" title="0">{
                        b.WriteString(styleSelected.Render(line) + "\n")
                }</span> else<span class="cov0" title="0"> {
                        b.WriteString(line + "\n")
                }</span>
        }
        <span class="cov0" title="0">m.reflogViewport.SetContent(b.String())</span>
}

func (m model) viewReflog() string <span class="cov0" title="0">{
        s := m.renderHeader()
        s += styleTitle.Render(" Time Machine (Reflog) ") + "\n"
        s += m.reflogViewport.View() + "\n"
        s += "Shortcuts: [j/k/up/down] scroll | [esc/q/g] back\n"
        return s
}</span>

func (m *model) renderHistory() <span class="cov0" title="0">{
        var b strings.Builder
        for i, c := range m.commits </span><span class="cov0" title="0">{
                marker := "â—‹"
                if len(c.Parents) &gt; 1 </span><span class="cov0" title="0">{
                        marker = "Î¦" // merge symbol looks pro
                }</span>

                <span class="cov0" title="0">prefix := "  "
                if m.historyCursor == i </span><span class="cov0" title="0">{
                        prefix = "â¯ "
                }</span>

                <span class="cov0" title="0">line := fmt.Sprintf("%s%s [%s] %s (%s)",
                        prefix,
                        styleBranch.Render(marker),
                        styleSelected.Render(c.ShortHash),
                        c.Message,
                        c.Date)

                if m.historyCursor == i </span><span class="cov0" title="0">{
                        b.WriteString(styleSelected.Render(line) + "\n")
                }</span> else<span class="cov0" title="0"> {
                        b.WriteString(line + "\n")
                }</span>

                // extra details if expanded
                <span class="cov0" title="0">if m.expandedHistory[c.Hash] </span><span class="cov0" title="0">{
                        b.WriteString(fmt.Sprintf("    %s Author: %s &lt;%s&gt;\n", styleAlert.Render(""), c.Author, c.Email))
                        b.WriteString(fmt.Sprintf("    %s Hash: %s\n", styleAlert.Render(""), c.Hash))
                }</span> else<span class="cov0" title="0"> if m.historyCursor == i </span><span class="cov0" title="0">{
                        b.WriteString(lipgloss.NewStyle().Foreground(lipgloss.Color("240")).Render("    [Tip: Press Enter for details]") + "\n")
                }</span>

                <span class="cov0" title="0">if i &lt; len(m.commits)-1 </span><span class="cov0" title="0">{
                        b.WriteString("  â”‚\n")
                }</span>
        }
        <span class="cov0" title="0">m.historyViewport.SetContent(b.String())</span>
}

func (m model) viewHistory() string <span class="cov0" title="0">{
        s := m.renderHeader()
        s += styleTitle.Render(" Visual History ") + "\n"
        s += m.historyViewport.View() + "\n"
        s += "Shortcuts: [j/k/up/down] scroll | [enter] details | [R] interactive rebase | [L] summary | [esc/q/h] back\n"
        return s
}</span>

func (m model) viewWorkspaces() string <span class="cov0" title="0">{
        s := m.renderHeader()
        header := styleWS.Render(" Logical Workspaces ")
        if m.isUpdating </span><span class="cov0" title="0">{
                header += " (updating...)"
        }</span>

        <span class="cov0" title="0">s += header + "\n\n"

        if m.meta == nil || len(m.meta.Workspaces) == 0 </span><span class="cov0" title="0">{
                s += "  No workspace created. Press [n] to create a new one.\n"
        }</span> else<span class="cov0" title="0"> {
                for i, w := range m.meta.Workspaces </span><span class="cov0" title="0">{
                        cursor := "  "
                        if m.cursor == i </span><span class="cov0" title="0">{
                                cursor = "&gt; "
                        }</span>
                        <span class="cov0" title="0">active := ""
                        if m.meta.ActiveWorkspace == w.ID </span><span class="cov0" title="0">{
                                active = " \u2605"
                        }</span>
                        <span class="cov0" title="0">line := fmt.Sprintf("%s %s (%d commits)%s", cursor, w.Name, len(w.Commits), active)
                        if w.Description != "" </span><span class="cov0" title="0">{
                                line += fmt.Sprintf(" \u2014 %s", w.Description)
                        }</span>
                        <span class="cov0" title="0">if m.cursor == i </span><span class="cov0" title="0">{
                                s += styleSelected.Render(line) + "\n"
                        }</span> else<span class="cov0" title="0"> {
                                s += line + "\n"
                        }</span>
                }
        }

        <span class="cov0" title="0">s += "\nShortcuts: [n] new | [a] activate | [w/esc] back\n"
        return s</span>
}

func (m model) viewNewWorkspace() string <span class="cov0" title="0">{
        s := m.renderHeader()
        s += styleWS.Render(" New Workspace ") + "\n\n"
        s += "Name:\n"
        s += m.newWsName.View() + "\n\n"
        s += "Description:\n"
        s += m.newWsDesc.View() + "\n\n"
        s += "Shortcuts: [tab] switch field | [enter] create and activate | [esc] cancel\n"
        return s
}</span>

func (m model) viewCommit() string <span class="cov0" title="0">{
        s := m.renderHeader()
        s += styleTitle.Render(" Commit ") + "\n\n"

        // show active workspace
        if m.meta != nil &amp;&amp; m.meta.ActiveWorkspace != "" </span><span class="cov0" title="0">{
                wsName := m.wsManager.GetActiveWorkspaceName(m.meta)
                s += fmt.Sprintf("active workspace: %s\n", styleWS.Render(" "+wsName+" "))
        }</span>

        // show auto-detected tag preview
        <span class="cov0" title="0">currentMsg := m.commitMsg.Value()
        if currentMsg != "" </span><span class="cov0" title="0">{
                detected := workspace.DetectTag(currentMsg)
                tagLabel := map[string]string{
                        "feature": "Feature", "fix": "Fix", "refactor": "Refactor",
                        "experiment": "Experiment", "none": "General",
                }
                s += fmt.Sprintf("detected tag: %s\n", tagLabel[detected])
        }</span>

        // show impact (butterfly style)
        <span class="cov0" title="0">impactLabel := map[string]string{
                "patch": "ðŸ¦‹ [PATCH]", "minor": "ðŸ¦‹ [MINOR]", "major": "ðŸ¦‹ [MAJOR]",
        }
        info := "(suggested)"
        if m.manualImpact != "" </span><span class="cov0" title="0">{
                info = "(Manual)"
        }</span>
        <span class="cov0" title="0">s += fmt.Sprintf("Impact: %s %s\n", impactLabel[m.decidedImpact], styleAlert.Render(info))

        s += "\n" + m.commitMsg.View() + "\n\n"
        s += "Tip: use prefixes like feat:, fix:, refactor: for auto-tagging\n"
        s += "Shortcuts: [enter] commit | [alt+i] impact | [esc] cancel\n"
        return s</span>
}

func (m model) viewSummary() string <span class="cov0" title="0">{
        s := m.renderHeader()
        title := " Release Summary "
        if m.isUpdating </span><span class="cov0" title="0">{
                title += "(Generating...)"
        }</span>
        <span class="cov0" title="0">s += styleTitle.Render(title) + "\n"
        s += m.summaryViewport.View() + "\n"
        s += "Shortcuts: [j/k/up/down] scroll | [E] export MD | [esc/q/L] back\n"
        return s</span>
}
</pre>
		
		<pre class="file" id="file7" style="display: none">package changelog

import (
        "context"
        "encoding/json"
        "fmt"
        "strings"
        "tutugit/internal/git"
        "tutugit/internal/workspace"
)

// ChangeEntry -&gt; represents a single normalized change in the history.
type ChangeEntry struct {
        Hash      string `json:"hash"`
        ShortHash string `json:"short_hash"`
        Author    string `json:"author"`
        Subject   string `json:"subject"`
        Tag       string `json:"tag"`
        Impact    string `json:"impact"`
        Workspace string `json:"workspace,omitempty"`
        Date      string `json:"date"`
}

// Release -&gt; represents a versioned collection of changes.
type Release struct {
        Version string        `json:"version"`
        Date    string        `json:"date"`
        Entries []ChangeEntry `json:"entries"`
}

// Generator -&gt; orchestrates the creation of release data from git and tutugit metadata.
type Generator struct {
        Git  git.GitProvider
        Meta *workspace.Meta
}

// NewGenerator -&gt; creates a new generator.
func NewGenerator(g git.GitProvider, m *workspace.Meta) *Generator <span class="cov8" title="1">{
        return &amp;Generator{Git: g, Meta: m}
}</span>

// GenerateRelease -&gt; collects commits for a specific range and returns a Release.
func (g *Generator) GenerateRelease(ctx context.Context, version, base, head string) (*Release, error) <span class="cov8" title="1">{
        commits, err := g.Git.GetCommitsInRange(ctx, base, head)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var entries []ChangeEntry
        for _, c := range commits </span><span class="cov8" title="1">{
                entry := ChangeEntry{
                        Hash:      c.Hash,
                        ShortHash: c.ShortHash,
                        Author:    c.Author,
                        Subject:   c.Message,
                        Date:      c.Date,
                }

                // associate with tag (nil-safe)
                if g.Meta != nil &amp;&amp; g.Meta.Tags != nil </span><span class="cov8" title="1">{
                        if tags, ok := g.Meta.Tags[c.Hash]; ok &amp;&amp; len(tags) &gt; 0 </span><span class="cov8" title="1">{
                                entry.Tag = tags[0]
                        }</span> else<span class="cov8" title="1"> {
                                entry.Tag = workspace.DetectTag(c.Message)
                        }</span>
                } else<span class="cov0" title="0"> {
                        entry.Tag = workspace.DetectTag(c.Message)
                }</span>

                // associate with workspace (nil-safe)
                <span class="cov8" title="1">if g.Meta != nil </span><span class="cov8" title="1">{
                        for _, ws := range g.Meta.Workspaces </span><span class="cov8" title="1">{
                                for _, h := range ws.Commits </span><span class="cov8" title="1">{
                                        if h == c.Hash </span><span class="cov8" title="1">{
                                                entry.Workspace = ws.Name
                                                break</span>
                                        }
                                }
                                <span class="cov8" title="1">if entry.Workspace != "" </span><span class="cov8" title="1">{
                                        break</span>
                                }
                        }
                }

                // associate with impact (nil-safe)
                <span class="cov8" title="1">if g.Meta != nil &amp;&amp; g.Meta.Impacts != nil </span><span class="cov8" title="1">{
                        if level, ok := g.Meta.Impacts[c.Hash]; ok </span><span class="cov8" title="1">{
                                entry.Impact = level
                        }</span> else<span class="cov8" title="1"> {
                                entry.Impact = workspace.DetectImpact(c.Message)
                        }</span>
                } else<span class="cov8" title="1"> {
                        entry.Impact = workspace.DetectImpact(c.Message)
                }</span>

                <span class="cov8" title="1">entries = append(entries, entry)</span>
        }

        <span class="cov8" title="1">date := ""
        if len(commits) &gt; 0 </span><span class="cov8" title="1">{
                date = commits[len(commits)-1].Date
        }</span>

        <span class="cov8" title="1">return &amp;Release{
                Version: version,
                Date:    date,
                Entries: entries,
        }, nil</span>
}

// GenerateFull -&gt; iterates through all tags to produce a complete release history.
func (g *Generator) GenerateFull(ctx context.Context) ([]*Release, error) <span class="cov8" title="1">{
        tags, err := g.Git.GetTags(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">var releases []*Release

        if len(tags) == 0 </span><span class="cov8" title="1">{
                rel, err := g.GenerateRelease(ctx, "Unreleased", "", "HEAD")
                if err == nil &amp;&amp; len(rel.Entries) &gt; 0 </span><span class="cov8" title="1">{
                        releases = append(releases, rel)
                }</span>
                <span class="cov8" title="1">return releases, nil</span>
        }

        <span class="cov8" title="1">headRel, err := g.GenerateRelease(ctx, "Unreleased", tags[0], "HEAD")
        if err == nil &amp;&amp; len(headRel.Entries) &gt; 0 </span><span class="cov8" title="1">{
                releases = append(releases, headRel)
        }</span>

        <span class="cov8" title="1">for i := 0; i &lt; len(tags)-1; i++ </span><span class="cov8" title="1">{
                rel, err := g.GenerateRelease(ctx, tags[i], tags[i+1], tags[i])
                if err == nil </span><span class="cov8" title="1">{
                        releases = append(releases, rel)
                }</span>
        }

        <span class="cov8" title="1">if len(tags) &gt; 0 </span><span class="cov8" title="1">{
                firstRel, err := g.GenerateRelease(ctx, tags[len(tags)-1], "", tags[len(tags)-1])
                if err == nil </span><span class="cov8" title="1">{
                        releases = append(releases, firstRel)
                }</span>
        }

        <span class="cov8" title="1">return releases, nil</span>
}

// FormatSummary -&gt; produces a clean, structured release summary.
func (g *Generator) FormatSummary(releases []*Release) string <span class="cov8" title="1">{
        if len(releases) == 0 </span><span class="cov8" title="1">{
                return "No releases found."
        }</span>

        <span class="cov8" title="1">var b strings.Builder

        for _, rel := range releases </span><span class="cov8" title="1">{
                // Count by tag
                counts := make(map[string]int)
                maxImpact := "patch"
                impactWeight := map[string]int{"patch": 0, "minor": 1, "major": 2}

                for _, e := range rel.Entries </span><span class="cov8" title="1">{
                        tag := e.Tag
                        if tag == "" || tag == "none" </span><span class="cov0" title="0">{
                                tag = "other"
                        }</span>
                        <span class="cov8" title="1">counts[tag]++
                        if impactWeight[e.Impact] &gt; impactWeight[maxImpact] </span><span class="cov8" title="1">{
                                maxImpact = e.Impact
                        }</span>
                }

                // Header
                <span class="cov8" title="1">b.WriteString(fmt.Sprintf("Release %s\n", rel.Version))
                b.WriteString(fmt.Sprintf("Impact: %s\n", maxImpact))

                // Change counts
                var parts []string
                order := []struct{ tag, label string }{
                        {"feature", "features"},
                        {"fix", "fixes"},
                        {"refactor", "refactors"},
                        {"experiment", "experiments"},
                        {"other", "other"},
                }
                for _, o := range order </span><span class="cov8" title="1">{
                        if c, ok := counts[o.tag]; ok &amp;&amp; c &gt; 0 </span><span class="cov8" title="1">{
                                parts = append(parts, fmt.Sprintf("%d %s", c, o.label))
                        }</span>
                }
                <span class="cov8" title="1">b.WriteString(fmt.Sprintf("Changes: %s\n", strings.Join(parts, ", ")))

                // Workspace (if consistent)
                wsSet := make(map[string]bool)
                for _, e := range rel.Entries </span><span class="cov8" title="1">{
                        if e.Workspace != "" </span><span class="cov8" title="1">{
                                wsSet[e.Workspace] = true
                        }</span>
                }
                <span class="cov8" title="1">if len(wsSet) == 1 </span><span class="cov8" title="1">{
                        for ws := range wsSet </span><span class="cov8" title="1">{
                                b.WriteString(fmt.Sprintf("Workspace: %s\n", ws))
                        }</span>
                } else<span class="cov0" title="0"> if len(wsSet) &gt; 1 </span><span class="cov0" title="0">{
                        var names []string
                        for ws := range wsSet </span><span class="cov0" title="0">{
                                names = append(names, ws)
                        }</span>
                        <span class="cov0" title="0">b.WriteString(fmt.Sprintf("Workspaces: %s\n", strings.Join(names, ", ")))</span>
                }

                <span class="cov8" title="1">b.WriteString("â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€\n")

                // Entries
                for _, e := range rel.Entries </span><span class="cov8" title="1">{
                        tag := e.Tag
                        if tag == "" || tag == "none" </span><span class="cov0" title="0">{
                                tag = "other"
                        }</span>
                        // Pad tag for alignment
                        <span class="cov8" title="1">padded := fmt.Sprintf("%-10s", tag+":")
                        b.WriteString(fmt.Sprintf("  %s %s (%s)\n", padded, e.Subject, e.ShortHash))</span>
                }
                <span class="cov8" title="1">b.WriteString("\n")</span>
        }

        <span class="cov8" title="1">return b.String()</span>
}

// ExportJSON -&gt; produces structured JSON for external tool consumption.
func (g *Generator) ExportJSON(releases []*Release) ([]byte, error) <span class="cov8" title="1">{
        return json.MarshalIndent(releases, "", "  ")
}</span>

// ExportMarkdown -&gt; produces a human-readable Markdown summary.
func (g *Generator) ExportMarkdown(releases []*Release) string <span class="cov8" title="1">{
        if len(releases) == 0 </span><span class="cov0" title="0">{
                return "# Release Summary\n\nNo releases found."
        }</span>

        <span class="cov8" title="1">var b strings.Builder
        b.WriteString("# Release Summary\n\n")

        for _, rel := range releases </span><span class="cov8" title="1">{
                // Count by tag
                counts := make(map[string]int)
                maxImpact := "patch"
                impactWeight := map[string]int{"patch": 0, "minor": 1, "major": 2}

                for _, e := range rel.Entries </span><span class="cov8" title="1">{
                        tag := e.Tag
                        if tag == "" || tag == "none" </span><span class="cov8" title="1">{
                                tag = "other"
                        }</span>
                        <span class="cov8" title="1">counts[tag]++
                        if impactWeight[e.Impact] &gt; impactWeight[maxImpact] </span><span class="cov8" title="1">{
                                maxImpact = e.Impact
                        }</span>
                }

                // Release Header
                <span class="cov8" title="1">b.WriteString(fmt.Sprintf("## %s\n", rel.Version))
                b.WriteString(fmt.Sprintf("- **Impact:** %s\n", maxImpact))

                // Change counts
                var parts []string
                order := []struct{ tag, label string }{
                        {"feature", "features"},
                        {"fix", "fixes"},
                        {"refactor", "refactors"},
                        {"experiment", "experiments"},
                        {"other", "other"},
                }
                for _, o := range order </span><span class="cov8" title="1">{
                        if c, ok := counts[o.tag]; ok &amp;&amp; c &gt; 0 </span><span class="cov8" title="1">{
                                parts = append(parts, fmt.Sprintf("%d %s", c, o.label))
                        }</span>
                }
                <span class="cov8" title="1">b.WriteString(fmt.Sprintf("- **Changes:** %s\n", strings.Join(parts, ", ")))

                // Workspace (if consistent)
                wsSet := make(map[string]bool)
                for _, e := range rel.Entries </span><span class="cov8" title="1">{
                        if e.Workspace != "" </span><span class="cov8" title="1">{
                                wsSet[e.Workspace] = true
                        }</span>
                }
                <span class="cov8" title="1">if len(wsSet) == 1 </span><span class="cov0" title="0">{
                        for ws := range wsSet </span><span class="cov0" title="0">{
                                b.WriteString(fmt.Sprintf("- **Workspace:** %s\n", ws))
                        }</span>
                } else<span class="cov8" title="1"> if len(wsSet) &gt; 1 </span><span class="cov8" title="1">{
                        var names []string
                        for ws := range wsSet </span><span class="cov8" title="1">{
                                names = append(names, ws)
                        }</span>
                        <span class="cov8" title="1">b.WriteString(fmt.Sprintf("- **Workspaces:** %s\n", strings.Join(names, ", ")))</span>
                }

                <span class="cov8" title="1">b.WriteString("\n---\n\n")

                // Entries
                for _, e := range rel.Entries </span><span class="cov8" title="1">{
                        tag := e.Tag
                        if tag == "" || tag == "none" </span><span class="cov8" title="1">{
                                tag = "other"
                        }</span>
                        <span class="cov8" title="1">b.WriteString(fmt.Sprintf("- **%s:** %s (`%s`)\n", tag, e.Subject, e.ShortHash))</span>
                }
                <span class="cov8" title="1">b.WriteString("\n")</span>
        }

        <span class="cov8" title="1">return b.String()</span>
}
</pre>
		
		<pre class="file" id="file8" style="display: none">package config

import (
        "fmt"
        "os"
        "path/filepath"

        "gopkg.in/yaml.v3"
)

// Config holds the project-level configuration for tutugit.
type Config struct {
        Schema  string  `yaml:"$schema,omitempty"`
        Project Project `yaml:"project"`
}

// Project holds basic project metadata.
type Project struct {
        Name        string `yaml:"name"`
        Description string `yaml:"description"`
}

// Manager handles loading and saving the config file.
type Manager struct {
        RootPath string
}

// NewManager creates a new config manager for the given repository root.
func NewManager(rootPath string) *Manager <span class="cov8" title="1">{
        return &amp;Manager{RootPath: rootPath}
}</span>

func (m *Manager) configPath() string <span class="cov8" title="1">{
        return filepath.Join(m.RootPath, ".tutugit", "config.yml")
}</span>

// Load reads the config from disk. Returns sensible defaults if the file doesn't exist.
func (m *Manager) Load() (*Config, error) <span class="cov8" title="1">{
        path := m.configPath()
        if _, err := os.Stat(path); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return DefaultConfig(), nil
        }</span>

        <span class="cov8" title="1">data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not read config: %w", err)
        }</span>

        <span class="cov8" title="1">var cfg Config
        if err := yaml.Unmarshal(data, &amp;cfg); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not parse config: %w", err)
        }</span>

        <span class="cov8" title="1">return &amp;cfg, nil</span>
}

// Save writes the config to disk.
func (m *Manager) Save(cfg *Config) error <span class="cov8" title="1">{
        path := m.configPath()
        dir := filepath.Dir(path)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not create .tutugit directory: %w", err)
        }</span>

        <span class="cov8" title="1">data, err := yaml.Marshal(cfg)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not serialize config: %w", err)
        }</span>

        // Prepend language server directive if schema is set
        <span class="cov8" title="1">if cfg.Schema != "" </span><span class="cov8" title="1">{
                directive := fmt.Sprintf("# yaml-language-server: $schema=%s\n", cfg.Schema)
                data = append([]byte(directive), data...)
        }</span>

        <span class="cov8" title="1">if err := os.WriteFile(path, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not write config: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// DefaultConfig returns a Config with sensible defaults.
func DefaultConfig() *Config <span class="cov8" title="1">{
        return &amp;Config{
                Schema: "./schemas/config.schema.json",
                Project: Project{
                        Name:        "",
                        Description: "",
                },
        }
}</span>
</pre>
		
		<pre class="file" id="file9" style="display: none">package diff

import (
        "strings"
)

// Hunk -&gt; represents a single change block in a diff.
type Hunk struct {
        Header  string
        Content string
}

// FileDiff -&gt; represents all changes in a single file.
type FileDiff struct {
        Path  string
        Hunks []Hunk
}

// ParseDiff -&gt; splits a raw diff string into FileDiffs and Hunks.
func ParseDiff(raw string) []FileDiff <span class="cov8" title="1">{
        var files []FileDiff
        var currentFile *FileDiff
        var currentHunk *Hunk

        lines := strings.Split(raw, "\n")
        for _, line := range lines </span><span class="cov8" title="1">{
                if strings.HasPrefix(line, "diff --git") </span><span class="cov8" title="1">{
                        if currentFile != nil </span><span class="cov8" title="1">{
                                if currentHunk != nil </span><span class="cov8" title="1">{
                                        currentFile.Hunks = append(currentFile.Hunks, *currentHunk)
                                        currentHunk = nil
                                }</span>
                                <span class="cov8" title="1">files = append(files, *currentFile)</span>
                        }
                        <span class="cov8" title="1">parts := strings.Split(line, " ")
                        path := ""
                        if len(parts) &gt; 2 </span><span class="cov8" title="1">{
                                path = strings.TrimPrefix(parts[2], "a/")
                        }</span>
                        <span class="cov8" title="1">currentFile = &amp;FileDiff{Path: path}
                        continue</span>
                }

                <span class="cov8" title="1">if strings.HasPrefix(line, "@@") </span><span class="cov8" title="1">{
                        if currentHunk != nil &amp;&amp; currentFile != nil </span><span class="cov8" title="1">{
                                currentFile.Hunks = append(currentFile.Hunks, *currentHunk)
                        }</span>
                        <span class="cov8" title="1">currentHunk = &amp;Hunk{Header: line, Content: line + "\n"}
                        continue</span>
                }

                <span class="cov8" title="1">if currentHunk != nil </span><span class="cov8" title="1">{
                        currentHunk.Content += line + "\n"
                }</span>
        }

        <span class="cov8" title="1">if currentFile != nil </span><span class="cov8" title="1">{
                if currentHunk != nil </span><span class="cov8" title="1">{
                        currentFile.Hunks = append(currentFile.Hunks, *currentHunk)
                }</span>
                <span class="cov8" title="1">files = append(files, *currentFile)</span>
        }

        <span class="cov8" title="1">return files</span>
}

// ToPatch returns a string that can be used with `git apply`.
func (h *Hunk) ToPatch(filePath string) string <span class="cov0" title="0">{
        var b strings.Builder
        b.WriteString("diff --git a/" + filePath + " b/" + filePath + "\n")
        b.WriteString("--- a/" + filePath + "\n")
        b.WriteString("+++ b/" + filePath + "\n")
        b.WriteString(h.Content)
        return b.String()
}</span>
</pre>
		
		<pre class="file" id="file10" style="display: none">package git

import (
        "bytes"
        "context"
        "fmt"
        "os"
        "os/exec"
        "strings"
)

const (
        // Git log parsing constants
        minLogPartsCount = 7 // Minimum number of fields in a parsed log entry
)

// GitProvider defines the operations needed by tutugit's semantic layer.
type GitProvider interface {
        Run(ctx context.Context, args ...string) (string, error)
        GetCurrentBranch(ctx context.Context) (string, error)
        GetStatus(ctx context.Context) (string, error)
        StageFile(ctx context.Context, path string) error
        UnstageFile(ctx context.Context, path string) error
        Commit(ctx context.Context, message string) error
        GetLastCommitHash(ctx context.Context) (string, error)
        GetRemoteURL(ctx context.Context) (string, error)
        GetDiff(ctx context.Context, path string, staged bool) (string, error)
        ApplyHunk(ctx context.Context, patch string) error
        GetLog(ctx context.Context, n int) ([]Commit, error)
        GetReflog(ctx context.Context, n int) ([]ReflogEntry, error)
        ListWorktrees(ctx context.Context) ([]Worktree, error)
        AddWorktree(ctx context.Context, path, branch string) error
        RemoveWorktree(ctx context.Context, path string, force bool) error
        ResetToHash(ctx context.Context, target string) error
        IsRebasing(ctx context.Context) bool
        RebaseContinue(ctx context.Context) error
        RebaseAbort(ctx context.Context) error
        RebaseSkip(ctx context.Context) error
        GetCommitsInRange(ctx context.Context, base, head string) ([]Commit, error)
        ParseStatus(ctx context.Context) ([]FileStatus, error)
        GetTags(ctx context.Context) ([]string, error)
        ValidateHash(ctx context.Context, hash string) bool
        RunInteractiveRebase(ctx context.Context, base string, steps []RebaseStep) error
}

// Runner -&gt; handles the execution of git commands.
type Runner struct {
        Cwd string
}

// NewRunner -&gt; creates a new git runner in the specified directory.
func NewRunner(cwd string) GitProvider <span class="cov8" title="1">{
        return &amp;Runner{Cwd: cwd}
}</span>

// gitCommand -&gt; creates a git command with the correct directory and context.
func (r *Runner) gitCommand(ctx context.Context, args ...string) *exec.Cmd <span class="cov8" title="1">{
        cmd := exec.CommandContext(ctx, "git", args...)
        cmd.Dir = r.Cwd
        cmd.Env = append(os.Environ(),
                "GIT_TERMINAL_PROMPT=0",
                "GIT_PAGER=cat",
                "PAGER=cat",
        )
        return cmd
}</span>

// Run -&gt; executes a git command and returns the stdout strings.
func (r *Runner) Run(ctx context.Context, args ...string) (string, error) <span class="cov8" title="1">{
        cmd := r.gitCommand(ctx, args...)

        var stdout, stderr bytes.Buffer
        cmd.Stdout = &amp;stdout
        cmd.Stderr = &amp;stderr

        if err := cmd.Run(); err != nil </span><span class="cov8" title="1">{
                return "", fmt.Errorf("git %s failed: %w\nstderr: %s\nstdout: %s",
                        strings.Join(args, " "), err,
                        strings.TrimSpace(stderr.String()),
                        strings.TrimSpace(stdout.String()))
        }</span>

        <span class="cov8" title="1">return stdout.String(), nil</span>
}

// GetCurrentBranch -&gt; returns the current active branch name.
func (r *Runner) GetCurrentBranch(ctx context.Context) (string, error) <span class="cov8" title="1">{
        branch, err := r.Run(ctx, "rev-parse", "--abbrev-ref", "HEAD")
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("could not get branch: %w", err)
        }</span>
        <span class="cov8" title="1">return strings.TrimSpace(branch), nil</span>
}

// GetStatus -&gt; returns the porcelain status of the repository.
func (r *Runner) GetStatus(ctx context.Context) (string, error) <span class="cov8" title="1">{
        status, err := r.Run(ctx, "status", "--porcelain")
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("could not get status: %w", err)
        }</span>
        <span class="cov8" title="1">return status, nil</span>
}

// StageFile -&gt; adds a file to the staging area.
func (r *Runner) StageFile(ctx context.Context, path string) error <span class="cov8" title="1">{
        _, err := r.Run(ctx, "add", path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not add file %s: %w", path, err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// UnstageFile -&gt; removes a file from the staging area.
func (r *Runner) UnstageFile(ctx context.Context, path string) error <span class="cov8" title="1">{
        // this uses 'reset' to unstage.
        // for new files it works as well.
        _, err := r.Run(ctx, "reset", "HEAD", "--", path)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not unstage file %s: %w", path, err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Commit -&gt; creates a new commit with the given message.
func (r *Runner) Commit(ctx context.Context, message string) error <span class="cov8" title="1">{
        _, err := r.Run(ctx, "commit", "-m", message)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("commit failed: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// GetLastCommitHash -&gt; returns the SHA of the HEAD commit.
func (r *Runner) GetLastCommitHash(ctx context.Context) (string, error) <span class="cov8" title="1">{
        hash, err := r.Run(ctx, "rev-parse", "HEAD")
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("could not get last commit hash: %w", err)
        }</span>
        <span class="cov8" title="1">return strings.TrimSpace(hash), nil</span>
}

// GetRemoteURL -&gt; returns the URL of the "origin" remote, or empty string if not set.
func (r *Runner) GetRemoteURL(ctx context.Context) (string, error) <span class="cov8" title="1">{
        url, err := r.Run(ctx, "remote", "get-url", "origin")
        if err != nil </span><span class="cov8" title="1">{
                return "", nil // no remote is not an error
        }</span>
        <span class="cov8" title="1">return strings.TrimSpace(url), nil</span>
}

// GetDiff -&gt; returns the diff of a file. If staged is true, it shows staged changes.
func (r *Runner) GetDiff(ctx context.Context, path string, staged bool) (string, error) <span class="cov8" title="1">{
        args := []string{"diff"}
        if staged </span><span class="cov8" title="1">{
                args = append(args, "--cached")
        }</span>
        <span class="cov8" title="1">args = append(args, "--", path)

        diff, err := r.Run(ctx, args...)
        if err != nil </span><span class="cov0" title="0">{
                return "", fmt.Errorf("could not get diff for %s: %w", path, err)
        }</span>
        <span class="cov8" title="1">return diff, nil</span>
}

// ApplyHunk -&gt; stages a specific hunk using git apply --cached.
func (r *Runner) ApplyHunk(ctx context.Context, patch string) error <span class="cov8" title="1">{
        cmd := r.gitCommand(ctx, "apply", "--cached", "-")
        cmd.Stdin = strings.NewReader(patch)

        if err := cmd.Run(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not apply hunk: %w", err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// Commit -&gt; represents a single git commit.
type Commit struct {
        Hash      string
        ShortHash string
        Parents   []string
        Author    string
        Email     string
        Date      string
        Message   string
        Body      string
}

// GetLog -&gt; returns the commit history.
func (r *Runner) GetLog(ctx context.Context, n int) ([]Commit, error) <span class="cov8" title="1">{
        // %x1f = Unit Separator
        // %x1e = Record Separator
        format := "%H%x1f%h%x1f%P%x1f%an%x1f%ae%x1f%cr%x1f%s%x1f%B%x1f%x1e"
        args := []string{"log", fmt.Sprintf("-n%d", n), "--pretty=format:" + format}
        return r.parseLog(ctx, args)
}</span>

func (r *Runner) parseLog(ctx context.Context, args []string) ([]Commit, error) <span class="cov8" title="1">{
        output, err := r.Run(ctx, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not get git log: %w", err)
        }</span>

        <span class="cov8" title="1">if output == "" </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">records := strings.Split(output, "\x1e")
        var commits []Commit
        for _, record := range records </span><span class="cov8" title="1">{
                record = strings.TrimSpace(record)
                if record == "" </span><span class="cov8" title="1">{
                        continue</span>
                }
                <span class="cov8" title="1">parts := strings.Split(record, "\x1f")
                if len(parts) &lt; minLogPartsCount </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">var parents []string
                if parts[2] != "" </span><span class="cov8" title="1">{
                        parents = strings.Split(parts[2], " ")
                }</span>

                <span class="cov8" title="1">c := Commit{
                        Hash:      parts[0],
                        ShortHash: parts[1],
                        Parents:   parents,
                        Author:    parts[3],
                        Email:     parts[4],
                        Date:      parts[5],
                        Message:   parts[6],
                }
                if len(parts) &gt; 7 </span><span class="cov8" title="1">{
                        c.Body = parts[7]
                }</span>
                <span class="cov8" title="1">commits = append(commits, c)</span>
        }
        <span class="cov8" title="1">return commits, nil</span>
}

// ReflogEntry represents an entry in the git reflog.
type ReflogEntry struct {
        Hash     string
        Selector string // e.g. HEAD@{0}
        Action   string // e.g. commit, rebase, reset
        Message  string
        Date     string
}

// GetReflog -&gt; returns the git reflog.
func (r *Runner) GetReflog(ctx context.Context, n int) ([]ReflogEntry, error) <span class="cov8" title="1">{
        // using --date=relative and custom format
        format := "%H|%gD|%gs|%gd"
        args := []string{"reflog", fmt.Sprintf("-n%d", n), "--pretty=format:" + format}

        output, err := r.Run(ctx, args...)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not get git reflog: %w", err)
        }</span>

        <span class="cov8" title="1">if output == "" </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">lines := strings.Split(output, "\n")
        var entries []ReflogEntry
        for _, line := range lines </span><span class="cov8" title="1">{
                parts := strings.Split(line, "|")
                if len(parts) &lt; 3 </span><span class="cov0" title="0">{
                        continue</span>
                }

                // parts: hash | selector | subject | (sometimes date if format is different)
                // subject often contains "action: message"
                <span class="cov8" title="1">subject := parts[2]
                action := "unknown"
                message := subject

                if strings.Contains(subject, ": ") </span><span class="cov8" title="1">{
                        subParts := strings.SplitN(subject, ": ", 2)
                        action = subParts[0]
                        message = subParts[1]
                }</span> else<span class="cov0" title="0"> if strings.HasPrefix(subject, "commit") </span><span class="cov0" title="0">{
                        action = "commit"
                }</span>

                <span class="cov8" title="1">entries = append(entries, ReflogEntry{
                        Hash:     parts[0],
                        Selector: parts[1],
                        Action:   action,
                        Message:  message,
                })</span>
        }
        <span class="cov8" title="1">return entries, nil</span>
}

// Worktree represents a git worktree.
type Worktree struct {
        Path   string
        Branch string
        Hash   string
        IsMain bool
}

// ListWorktrees -&gt; returns the list of registered worktrees.
func (r *Runner) ListWorktrees(ctx context.Context) ([]Worktree, error) <span class="cov8" title="1">{
        output, err := r.Run(ctx, "worktree", "list", "--porcelain")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not list worktrees: %w", err)
        }</span>

        <span class="cov8" title="1">if output == "" </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">var worktrees []Worktree
        var current Worktree
        lines := strings.Split(output, "\n")

        for _, line := range lines </span><span class="cov8" title="1">{
                if line == "" </span><span class="cov8" title="1">{
                        if current.Path != "" </span><span class="cov8" title="1">{
                                worktrees = append(worktrees, current)
                                current = Worktree{}
                        }</span>
                        <span class="cov8" title="1">continue</span>
                }

                <span class="cov8" title="1">parts := strings.SplitN(line, " ", 2)
                if len(parts) &lt; 2 </span><span class="cov0" title="0">{
                        continue</span>
                }

                <span class="cov8" title="1">key := parts[0]
                value := parts[1]

                switch key </span>{
                case "worktree":<span class="cov8" title="1">
                        current.Path = value</span>
                case "branch":<span class="cov8" title="1">
                        current.Branch = strings.TrimPrefix(value, "refs/heads/")</span>
                case "HEAD":<span class="cov8" title="1">
                        current.Hash = value</span>
                }
        }

        // final one if no trailing newline
        <span class="cov8" title="1">if current.Path != "" </span><span class="cov0" title="0">{
                worktrees = append(worktrees, current)
        }</span>
        // identify main worktree (usually the one containing .git as a directory)
        <span class="cov8" title="1">for i := range worktrees </span><span class="cov8" title="1">{
                if i == 0 </span><span class="cov8" title="1">{
                        worktrees[i].IsMain = true // first in porcelain is main
                }</span>
        }

        <span class="cov8" title="1">return worktrees, nil</span>
}

// AddWorktree -&gt; adds a new worktree.
func (r *Runner) AddWorktree(ctx context.Context, path, branch string) error <span class="cov8" title="1">{
        args := []string{"worktree", "add", path, branch}
        _, err := r.Run(ctx, args...)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not add worktree at %s: %w", path, err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// RemoveWorktree -&gt; takes a worktree path and removes it.
func (r *Runner) RemoveWorktree(ctx context.Context, path string, force bool) error <span class="cov8" title="1">{
        args := []string{"worktree", "remove", path}
        if force </span><span class="cov8" title="1">{
                args = append(args, "--force")
        }</span>
        <span class="cov8" title="1">_, err := r.Run(ctx, args...)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not remove worktree %s: %w", path, err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// ResetToHash -&gt; performs a reset to a specific commit or reflog selector.
func (r *Runner) ResetToHash(ctx context.Context, target string) error <span class="cov8" title="1">{
        _, err := r.Run(ctx, "reset", "--hard", target)
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not reset to %s: %w", target, err)
        }</span>
        <span class="cov8" title="1">return nil</span>
}

// RebaseAction represents a git rebase command.
type RebaseAction string

const (
        ActionPick   RebaseAction = "pick"
        ActionSquash RebaseAction = "squash"
        ActionFixup  RebaseAction = "fixup"
        ActionEdit   RebaseAction = "edit"
        ActionDrop   RebaseAction = "drop"
        ActionReword RebaseAction = "reword"
)

// RebaseStep -&gt; represents a single step in a rebase todo list.
type RebaseStep struct {
        Action  RebaseAction
        Hash    string
        Message string
}

// IsRebasing -&gt; checks if a rebase is currently in progress.
func (r *Runner) IsRebasing(ctx context.Context) bool <span class="cov8" title="1">{
        // this simple check is to see if the .git/rebase-merge or .git/rebase-apply directory exists.
        // but checking the output of a rebase command is more reliable and direct.
        _, err := r.Run(ctx, "rebase", "--show-current-patch")
        return err == nil
}</span>

// RebaseContinue -&gt; continues an ongoing rebase.
func (r *Runner) RebaseContinue(ctx context.Context) error <span class="cov8" title="1">{
        _, err := r.Run(ctx, "rebase", "--continue")
        return err
}</span>

// RebaseAbort -&gt; aborts an ongoing rebase.
func (r *Runner) RebaseAbort(ctx context.Context) error <span class="cov8" title="1">{
        _, err := r.Run(ctx, "rebase", "--abort")
        return err
}</span>

// RebaseSkip -&gt; skips the current patch in a rebase.
func (r *Runner) RebaseSkip(ctx context.Context) error <span class="cov8" title="1">{
        _, err := r.Run(ctx, "rebase", "--skip")
        return err
}</span>

// GetCommitsInRange returns commits between base and head (excluding base).
func (r *Runner) GetCommitsInRange(ctx context.Context, base, head string) ([]Commit, error) <span class="cov8" title="1">{
        format := "%H%x1f%h%x1f%P%x1f%an%x1f%ae%x1f%cr%x1f%s%x1f%B%x1f%x1e"
        rangeSpec := fmt.Sprintf("%s..%s", base, head)
        if base == "" </span><span class="cov0" title="0">{
                rangeSpec = head
        }</span>
        <span class="cov8" title="1">args := []string{"log", "--pretty=format:" + format, "--reverse", rangeSpec}
        return r.parseLog(ctx, args)</span>
}

// RunInteractiveRebase -&gt; executes an interactive rebase using the provided steps.
func (r *Runner) RunInteractiveRebase(ctx context.Context, base string, steps []RebaseStep) error <span class="cov8" title="1">{
        var b strings.Builder
        for _, s := range steps </span><span class="cov8" title="1">{
                b.WriteString(fmt.Sprintf("%s %s %s\n", s.Action, s.Hash, s.Message))
        }</span>

        // create a temp file with the rebase todo content
        <span class="cov8" title="1">tmpFile, err := os.CreateTemp("", "tutugit-rebase-todo-*")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not create temp rebase todo: %w", err)
        }</span>
        <span class="cov8" title="1">defer os.Remove(tmpFile.Name())
        defer tmpFile.Close()

        if _, err := tmpFile.Write([]byte(b.String())); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not write rebase todo: %w", err)
        }</span>

        // Close explicitly to ensure flush before git reads it
        <span class="cov8" title="1">if err := tmpFile.Close(); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("could not close temp file: %w", err)
        }</span>

        // Use printf to safely escape the file path
        <span class="cov8" title="1">editorCmd := fmt.Sprintf("cp %q", tmpFile.Name())

        cmd := r.gitCommand(ctx, "rebase", "-i", base)
        cmd.Env = append(os.Environ(),
                "GIT_SEQUENCE_EDITOR="+editorCmd,
                "GIT_EDITOR=true",
        )

        var stderr bytes.Buffer
        cmd.Stderr = &amp;stderr

        if err := cmd.Run(); err != nil </span><span class="cov8" title="1">{
                // note: Rebase might fail with conflicts, which is "expected" if conflicts occur !!!!
                return fmt.Errorf("rebase failed: %w (stderr: %s)", err, stderr.String())
        }</span>

        <span class="cov0" title="0">return nil</span>
}

// FileStatus -&gt; represents the status of a single file.
type FileStatus struct {
        Path     string
        Staged   bool
        Modified bool
        New      bool
        Deleted  bool
}

// ParseStatus -&gt; parses the git status --short output.
func (r *Runner) ParseStatus(ctx context.Context) ([]FileStatus, error) <span class="cov8" title="1">{
        output, err := r.GetStatus(ctx)
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        <span class="cov8" title="1">if output == "" </span><span class="cov0" title="0">{
                return nil, nil
        }</span>

        <span class="cov8" title="1">lines := strings.Split(output, "\n")
        var files []FileStatus
        for _, line := range lines </span><span class="cov8" title="1">{
                if len(line) &lt; 4 </span><span class="cov8" title="1">{ // Minimum: "XY P"
                        continue</span>
                }

                // git porcelain format: "XY PATH"
                // X: status of the index
                // Y: status of the work tree
                <span class="cov8" title="1">stagedStatus := line[0]
                unstagedStatus := line[1]
                path := strings.TrimSpace(line[2:]) // path starts after "XY", skip the index 2 space and trim others

                f := FileStatus{Path: path}

                // Logic for Staged (X column)
                // If X is not ' ' and not '?', it's staged in some way.
                if stagedStatus != ' ' &amp;&amp; stagedStatus != '?' </span><span class="cov8" title="1">{
                        f.Staged = true
                }</span>

                // Logic for Flags
                <span class="cov8" title="1">if stagedStatus == 'M' || unstagedStatus == 'M' </span><span class="cov8" title="1">{
                        f.Modified = true
                }</span>
                <span class="cov8" title="1">if stagedStatus == 'A' || stagedStatus == '?' || unstagedStatus == '?' </span><span class="cov8" title="1">{
                        f.New = true
                }</span>
                <span class="cov8" title="1">if stagedStatus == 'D' || unstagedStatus == 'D' </span><span class="cov0" title="0">{
                        f.Deleted = true
                }</span>

                <span class="cov8" title="1">files = append(files, f)</span>
        }
        <span class="cov8" title="1">return files, nil</span>
}

// GetTags -&gt; returns a list of all tags in the repository.
func (r *Runner) GetTags(ctx context.Context) ([]string, error) <span class="cov8" title="1">{
        output, err := r.Run(ctx, "tag", "-l", "--sort=-v:refname")
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("could not list tags: %w", err)
        }</span>
        <span class="cov8" title="1">if output == "" </span><span class="cov0" title="0">{
                return nil, nil
        }</span>
        <span class="cov8" title="1">return strings.Split(strings.TrimSpace(output), "\n"), nil</span>
}

// ValidateHash -&gt; checks if a commit hash exists and is reachable from any branch.
func (r *Runner) ValidateHash(ctx context.Context, hash string) bool <span class="cov8" title="1">{
        output, err := r.Run(ctx, "branch", "-a", "--contains", hash)
        return err == nil &amp;&amp; strings.TrimSpace(output) != ""
}</span>
</pre>
		
		<pre class="file" id="file11" style="display: none">package git

import (
        "context"
)

// MockRunner is a mock implementation of GitProvider for testing.
type MockRunner struct {
        CurrentBranch string
        Status        string
        Files         []FileStatus
        Commits       []Commit
        Reflog        []ReflogEntry
        Worktrees     []Worktree
        Tags          []string
        RemoteURL     string
        IsRebasingVal bool
        RebaseTodo    []RebaseStep
        ValidHashes   map[string]bool
        RunFunc       func(ctx context.Context, args ...string) (string, error)
        GetDiffFunc   func(ctx context.Context, path string, staged bool) (string, error)
}

func NewMockRunner() *MockRunner <span class="cov0" title="0">{
        return &amp;MockRunner{
                ValidHashes: make(map[string]bool),
        }
}</span>

func (m *MockRunner) Run(ctx context.Context, args ...string) (string, error) <span class="cov0" title="0">{
        if m.RunFunc != nil </span><span class="cov0" title="0">{
                return m.RunFunc(ctx, args...)
        }</span>
        <span class="cov0" title="0">return "", nil</span>
}

func (m *MockRunner) GetCurrentBranch(ctx context.Context) (string, error) <span class="cov0" title="0">{
        return m.CurrentBranch, nil
}</span>

func (m *MockRunner) GetStatus(ctx context.Context) (string, error) <span class="cov0" title="0">{
        return m.Status, nil
}</span>

func (m *MockRunner) StageFile(ctx context.Context, path string) error   <span class="cov0" title="0">{ return nil }</span>
func (m *MockRunner) UnstageFile(ctx context.Context, path string) error <span class="cov0" title="0">{ return nil }</span>
func (m *MockRunner) Commit(ctx context.Context, message string) error   <span class="cov0" title="0">{ return nil }</span>

func (m *MockRunner) GetLastCommitHash(ctx context.Context) (string, error) <span class="cov0" title="0">{
        if len(m.Commits) &gt; 0 </span><span class="cov0" title="0">{
                return m.Commits[0].Hash, nil
        }</span>
        <span class="cov0" title="0">return "abc1234", nil</span>
}

func (m *MockRunner) GetRemoteURL(ctx context.Context) (string, error) <span class="cov0" title="0">{
        return m.RemoteURL, nil
}</span>

func (m *MockRunner) GetDiff(ctx context.Context, path string, staged bool) (string, error) <span class="cov0" title="0">{
        if m.GetDiffFunc != nil </span><span class="cov0" title="0">{
                return m.GetDiffFunc(ctx, path, staged)
        }</span>
        <span class="cov0" title="0">return "", nil</span>
}

func (m *MockRunner) ApplyHunk(ctx context.Context, patch string) error <span class="cov0" title="0">{ return nil }</span>

func (m *MockRunner) GetLog(ctx context.Context, n int) ([]Commit, error) <span class="cov0" title="0">{
        if n &lt; len(m.Commits) </span><span class="cov0" title="0">{
                return m.Commits[:n], nil
        }</span>
        <span class="cov0" title="0">return m.Commits, nil</span>
}

func (m *MockRunner) GetReflog(ctx context.Context, n int) ([]ReflogEntry, error) <span class="cov0" title="0">{
        if n &lt; len(m.Reflog) </span><span class="cov0" title="0">{
                return m.Reflog[:n], nil
        }</span>
        <span class="cov0" title="0">return m.Reflog, nil</span>
}

func (m *MockRunner) ListWorktrees(ctx context.Context) ([]Worktree, error) <span class="cov0" title="0">{
        return m.Worktrees, nil
}</span>

func (m *MockRunner) AddWorktree(ctx context.Context, path, branch string) error        <span class="cov0" title="0">{ return nil }</span>
func (m *MockRunner) RemoveWorktree(ctx context.Context, path string, force bool) error <span class="cov0" title="0">{ return nil }</span>
func (m *MockRunner) ResetToHash(ctx context.Context, target string) error              <span class="cov0" title="0">{ return nil }</span>

func (m *MockRunner) IsRebasing(ctx context.Context) bool <span class="cov0" title="0">{
        return m.IsRebasingVal
}</span>

func (m *MockRunner) RebaseContinue(ctx context.Context) error <span class="cov0" title="0">{ return nil }</span>
func (m *MockRunner) RebaseAbort(ctx context.Context) error    <span class="cov0" title="0">{ return nil }</span>
func (m *MockRunner) RebaseSkip(ctx context.Context) error     <span class="cov0" title="0">{ return nil }</span>

func (m *MockRunner) GetCommitsInRange(ctx context.Context, base, head string) ([]Commit, error) <span class="cov0" title="0">{
        // Simple simulation: return all commits for now, or could filter by hash
        return m.Commits, nil
}</span>

func (m *MockRunner) ParseStatus(ctx context.Context) ([]FileStatus, error) <span class="cov0" title="0">{
        return m.Files, nil
}</span>

func (m *MockRunner) GetTags(ctx context.Context) ([]string, error) <span class="cov0" title="0">{
        return m.Tags, nil
}</span>

func (m *MockRunner) ValidateHash(ctx context.Context, hash string) bool <span class="cov0" title="0">{
        return m.ValidHashes[hash]
}</span>

func (m *MockRunner) RunInteractiveRebase(ctx context.Context, base string, steps []RebaseStep) error <span class="cov0" title="0">{
        return nil
}</span>
</pre>
		
		<pre class="file" id="file12" style="display: none">package hygiene

import (
        "context"
        "strings"
        "tutugit/internal/git"
        "tutugit/internal/workspace"
)

// HealthReport -&gt; contains the results of repo hygiene checks.
type HealthReport struct {
        WIPCommits        []string
        SquashSuggestions []string // Workspace IDs that should be squashed
        StaleWorkspaces   []string // Workspace names with missing/rebased commits
        DirtyFiles        bool
}

// Analyzer -&gt; performs hygiene checks on the repository.
type Analyzer struct {
        Git git.GitProvider
        WS  *workspace.Manager
}

// NewAnalyzer -&gt; creates a new hygiene analyzer.
func NewAnalyzer(g git.GitProvider, w *workspace.Manager) *Analyzer <span class="cov8" title="1">{
        return &amp;Analyzer{Git: g, WS: w}
}</span>

// GetReport -&gt; generates a hygiene report for the current state.
func (a *Analyzer) GetReport(ctx context.Context) (*HealthReport, error) <span class="cov8" title="1">{
        report := &amp;HealthReport{}

        // this checks for dirty files
        status, err := a.Git.GetStatus(ctx)
        if err == nil &amp;&amp; status != "" </span><span class="cov8" title="1">{
                report.DirtyFiles = true
        }</span>

        // this loads metadata for further checks
        <span class="cov8" title="1">meta, err := a.WS.Load()
        if err != nil </span><span class="cov0" title="0">{
                return nil, err
        }</span>

        // this detects WIP commits in metadata or recent history
        // this checks recent commits (last 10) for "wip", "fixme", "temp"
        <span class="cov8" title="1">commits, err := a.Git.Run(ctx, "log", "-n", "10", "--format=%s")
        if err == nil </span><span class="cov8" title="1">{
                for _, msg := range strings.Split(commits, "\n") </span><span class="cov8" title="1">{
                        lower := strings.ToLower(msg)
                        if strings.Contains(lower, "wip") || strings.Contains(lower, "fixme") || strings.Contains(lower, "temp") </span><span class="cov8" title="1">{
                                report.WIPCommits = append(report.WIPCommits, msg)
                        }</span>
                }
        }

        // this suggests squashes for workspaces with &gt; 3 commits
        // also checks for stale commits in all workspaces
        <span class="cov8" title="1">for _, ws := range meta.Workspaces </span><span class="cov8" title="1">{
                if len(ws.Commits) &gt; 3 </span><span class="cov0" title="0">{
                        report.SquashSuggestions = append(report.SquashSuggestions, ws.Name)
                }</span>

                // this checks if any commit in this workspace is stale
                <span class="cov8" title="1">stale := false
                for _, hash := range ws.Commits </span><span class="cov8" title="1">{
                        if !a.Git.ValidateHash(ctx, hash) </span><span class="cov8" title="1">{
                                stale = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if stale </span><span class="cov8" title="1">{
                        report.StaleWorkspaces = append(report.StaleWorkspaces, ws.Name)
                }</span>
        }

        <span class="cov8" title="1">return report, nil</span>
}
</pre>
		
		<pre class="file" id="file13" style="display: none">package workspace

import (
        "regexp"
        "strings"
)

// commitPrefixRegex matches conventional commit prefixes like "feat:", "fix(scope):", "feat!:", etc.
var commitPrefixRegex = regexp.MustCompile(`(?i)^(feat|feature|fix|bugfix|refactor|experiment|exp)(\([^)]*\))?(!)?:\s*`)

// prefixToTag maps recognized prefixes to their semantic tag.
var prefixToTag = map[string]string{
        "feat":       "feature",
        "feature":    "feature",
        "fix":        "fix",
        "bugfix":     "fix",
        "refactor":   "refactor",
        "experiment": "experiment",
        "exp":        "experiment",
}

// DetectTag parses a commit message and returns the semantic tag based on
// its conventional commit prefix. Returns "none" if no known prefix is found.
func DetectTag(message string) string <span class="cov8" title="1">{
        msg := strings.TrimSpace(message)
        match := commitPrefixRegex.FindStringSubmatch(msg)
        if len(match) &lt; 2 </span><span class="cov8" title="1">{
                return "none"
        }</span>
        <span class="cov8" title="1">prefix := strings.ToLower(match[1])
        if tag, ok := prefixToTag[prefix]; ok </span><span class="cov8" title="1">{
                return tag
        }</span>
        <span class="cov0" title="0">return "none"</span>
}

// DetectImpact suggests the impact level (patch, minor, major) based on the commit message.
// - major: if it contains a breaking change indicator (!) in the prefix or 'BREAKING CHANGE' in body.
// - minor: if it's a 'feat' or 'feature'.
// - patch: for 'fix', 'refactor', etc.
func DetectImpact(message string) string <span class="cov8" title="1">{
        msg := strings.TrimSpace(message)
        lines := strings.Split(msg, "\n")
        header := lines[0]

        // MAJOR: breaking change indicator (!) in prefix, e.g., "feat!:"
        match := commitPrefixRegex.FindStringSubmatch(header)
        if len(match) &gt; 0 </span><span class="cov8" title="1">{
                // Group 3 is the optional !
                if match[3] == "!" </span><span class="cov8" title="1">{
                        return "major"
                }</span>
        }

        // MAJOR: "BREAKING CHANGE" in body
        <span class="cov8" title="1">if strings.Contains(msg, "BREAKING CHANGE") </span><span class="cov8" title="1">{
                return "major"
        }</span>

        <span class="cov8" title="1">if len(match) &gt; 0 </span><span class="cov8" title="1">{
                prefix := strings.ToLower(match[1])
                // MINOR: features
                if prefix == "feat" || prefix == "feature" </span><span class="cov8" title="1">{
                        return "minor"
                }</span>
        }

        // PATCH: default for everything else (fix, refactor, or non-prefix)
        <span class="cov8" title="1">return "patch"</span>
}
</pre>
		
		<pre class="file" id="file14" style="display: none">package workspace

import (
        "encoding/json"
        "fmt"
        "os"
        "path/filepath"
)

// Workspace -&gt; represents a logical grouping of commits.
type Workspace struct {
        ID          string   `json:"id"`
        Name        string   `json:"name"`
        Description string   `json:"description"`
        Commits     []string `json:"commits"`
        Status      string   `json:"status"`
}

// Meta -&gt; holds all the tutugit metadata.
type Meta struct {
        Schema          string              `json:"$schema,omitempty"`
        Version         int                 `json:"version"`
        Workspaces      []Workspace         `json:"workspaces"`
        Tags            map[string][]string `json:"tags"`             // Commit SHA -&gt; Tags
        ActiveWorkspace string              `json:"active_workspace"` // ID of the currently active workspace
        Impacts         map[string]string   `json:"impacts"`          // Commit SHA -&gt; Impact Level (patch/minor/major)
}

// Manager -&gt; handles the persistence of Tutugit metadata.
type Manager struct {
        RootPath string
}

// NewManager -&gt; creates a new manager for the given repository root.
func NewManager(rootPath string) *Manager <span class="cov8" title="1">{
        return &amp;Manager{RootPath: rootPath}
}</span>

func (m *Manager) metaPath() string <span class="cov8" title="1">{
        return filepath.Join(m.RootPath, ".tutugit", "meta.json")
}</span>

// Bootstrap -&gt; initializes the tutugit metadata in the repository.
func (m *Manager) Bootstrap() error <span class="cov8" title="1">{
        path := m.metaPath()
        if _, err := os.Stat(path); err == nil </span><span class="cov8" title="1">{
                return fmt.Errorf("tutugit already initialized in %s", path)
        }</span>

        <span class="cov8" title="1">dir := filepath.Dir(path)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error creating .tutugit directory: %w", err)
        }</span>

        // copy schemas to .tutugit/schemas
        <span class="cov8" title="1">if err := m.copySchemas(); err != nil </span><span class="cov8" title="1">{
                fmt.Printf("Warning: could not copy schemas: %v (falling back to remote references)\n", err)
        }</span>

        <span class="cov8" title="1">meta := &amp;Meta{
                Schema:  "./schemas/meta.schema.json",
                Version: 1,
                Workspaces: []Workspace{
                        {
                                ID:          "general",
                                Name:        "General",
                                Description: "Default project workspace",
                                Commits:     []string{},
                                Status:      "active",
                        },
                },
                Tags:            make(map[string][]string),
                ActiveWorkspace: "general",
                Impacts:         make(map[string]string),
        }

        return m.Save(meta)</span>
}

func (m *Manager) copySchemas() error <span class="cov8" title="1">{
        srcDir := filepath.Join(m.RootPath, "schemas")
        destDir := filepath.Join(m.RootPath, ".tutugit", "schemas")

        if _, err := os.Stat(srcDir); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return fmt.Errorf("schemas directory not found in project root")
        }</span>

        <span class="cov0" title="0">if err := os.MkdirAll(destDir, 0755); err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">files, err := os.ReadDir(srcDir)
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov0" title="0">for _, f := range files </span><span class="cov0" title="0">{
                if f.IsDir() </span><span class="cov0" title="0">{
                        continue</span>
                }
                <span class="cov0" title="0">src := filepath.Join(srcDir, f.Name())
                dest := filepath.Join(destDir, f.Name())

                data, err := os.ReadFile(src)
                if err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>

                <span class="cov0" title="0">if err := os.WriteFile(dest, data, 0644); err != nil </span><span class="cov0" title="0">{
                        return err
                }</span>
        }

        <span class="cov0" title="0">return nil</span>
}

// load reads the metadata from disk.
func (m *Manager) Load() (*Meta, error) <span class="cov8" title="1">{
        path := m.metaPath()
        if _, err := os.Stat(path); os.IsNotExist(err) </span><span class="cov8" title="1">{
                return &amp;Meta{
                        Workspaces: []Workspace{},
                        Tags:       make(map[string][]string),
                }, nil
        }</span>

        <span class="cov8" title="1">data, err := os.ReadFile(path)
        if err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to read meta file: %w", err)
        }</span>

        <span class="cov8" title="1">var meta Meta
        if err := json.Unmarshal(data, &amp;meta); err != nil </span><span class="cov0" title="0">{
                return nil, fmt.Errorf("failed to parse meta file: %w", err)
        }</span>

        <span class="cov8" title="1">if meta.Tags == nil </span><span class="cov0" title="0">{
                meta.Tags = make(map[string][]string)
        }</span>
        <span class="cov8" title="1">if meta.Impacts == nil </span><span class="cov0" title="0">{
                meta.Impacts = make(map[string]string)
        }</span>
        <span class="cov8" title="1">if meta.Version == 0 </span><span class="cov0" title="0">{
                meta.Version = 1
        }</span>

        <span class="cov8" title="1">return &amp;meta, nil</span>
}

// Save -&gt; writes the metadata to disk.
func (m *Manager) Save(meta *Meta) error <span class="cov8" title="1">{
        path := m.metaPath()
        dir := filepath.Dir(path)
        if err := os.MkdirAll(dir, 0755); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("error creating .tutugit directory: %w", err)
        }</span>

        <span class="cov8" title="1">data, err := json.MarshalIndent(meta, "", "  ")
        if err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to parse meta file: %w", err)
        }</span>

        <span class="cov8" title="1">if err := os.WriteFile(path, data, 0644); err != nil </span><span class="cov0" title="0">{
                return fmt.Errorf("failed to write meta file: %w", err)
        }</span>

        <span class="cov8" title="1">return nil</span>
}

// AddCommitToWorkspace -&gt; adds a commit SHA to a specific workspace.
func (m *Manager) AddCommitToWorkspace(workspaceID, commitSHA string) error <span class="cov8" title="1">{
        meta, err := m.Load()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">found := false
        for i, w := range meta.Workspaces </span><span class="cov8" title="1">{
                if w.ID == workspaceID </span><span class="cov8" title="1">{
                        for _, sha := range w.Commits </span><span class="cov8" title="1">{
                                if sha == commitSHA </span><span class="cov8" title="1">{
                                        return nil
                                }</span>
                        }
                        <span class="cov8" title="1">meta.Workspaces[i].Commits = append(meta.Workspaces[i].Commits, commitSHA)
                        found = true
                        break</span>
                }
        }

        <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                return fmt.Errorf("workspace %s not found", workspaceID)
        }</span>

        <span class="cov8" title="1">return m.Save(meta)</span>
}

// AddTag -&gt; associates a tag with a commit SHA.
func (m *Manager) AddTag(commitSHA, tag string) error <span class="cov8" title="1">{
        meta, err := m.Load()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if meta.Tags == nil </span><span class="cov0" title="0">{
                meta.Tags = make(map[string][]string)
        }</span>

        <span class="cov8" title="1">tags := meta.Tags[commitSHA]
        for _, t := range tags </span><span class="cov8" title="1">{
                if t == tag </span><span class="cov8" title="1">{
                        return nil
                }</span>
        }

        <span class="cov8" title="1">meta.Tags[commitSHA] = append(tags, tag)
        return m.Save(meta)</span>
}

// AddImpact -&gt; associates a change impact level with a commit SHA.
func (m *Manager) AddImpact(commitSHA, level string) error <span class="cov8" title="1">{
        meta, err := m.Load()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">if meta.Impacts == nil </span><span class="cov0" title="0">{
                meta.Impacts = make(map[string]string)
        }</span>

        <span class="cov8" title="1">meta.Impacts[commitSHA] = level
        return m.Save(meta)</span>
}

// CreateWorkspace -&gt; logical workspace.
func (m *Manager) CreateWorkspace(id, name, desc string) error <span class="cov8" title="1">{
        meta, err := m.Load()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        <span class="cov8" title="1">for _, w := range meta.Workspaces </span><span class="cov8" title="1">{
                if w.ID == id </span><span class="cov8" title="1">{
                        return fmt.Errorf("workspace %s already exists", id)
                }</span>
        }

        <span class="cov8" title="1">meta.Workspaces = append(meta.Workspaces, Workspace{
                ID:          id,
                Name:        name,
                Description: desc,
                Commits:     []string{},
                Status:      "active",
        })

        return m.Save(meta)</span>
}

// SetActiveWorkspace -&gt; sets the currently active workspace by ID.
func (m *Manager) SetActiveWorkspace(id string) error <span class="cov8" title="1">{
        meta, err := m.Load()
        if err != nil </span><span class="cov0" title="0">{
                return err
        }</span>

        // Validate that the workspace exists
        <span class="cov8" title="1">if id != "" </span><span class="cov8" title="1">{
                found := false
                for _, w := range meta.Workspaces </span><span class="cov8" title="1">{
                        if w.ID == id </span><span class="cov8" title="1">{
                                found = true
                                break</span>
                        }
                }
                <span class="cov8" title="1">if !found </span><span class="cov8" title="1">{
                        return fmt.Errorf("workspace %s not found", id)
                }</span>
        }

        <span class="cov8" title="1">meta.ActiveWorkspace = id
        return m.Save(meta)</span>
}

// GetActiveWorkspaceName -&gt; returns the name of the active workspace, or empty string.
func (m *Manager) GetActiveWorkspaceName(meta *Meta) string <span class="cov8" title="1">{
        for _, w := range meta.Workspaces </span><span class="cov8" title="1">{
                if w.ID == meta.ActiveWorkspace </span><span class="cov8" title="1">{
                        return w.Name
                }</span>
        }
        <span class="cov8" title="1">return ""</span>
}
</pre>
		
		</div>
	</body>
	<script>
	(function() {
		var files = document.getElementById('files');
		var visible;
		files.addEventListener('change', onChange, false);
		function select(part) {
			if (visible)
				visible.style.display = 'none';
			visible = document.getElementById(part);
			if (!visible)
				return;
			files.value = part;
			visible.style.display = 'block';
			location.hash = part;
		}
		function onChange() {
			select(files.value);
			window.scrollTo(0, 0);
		}
		if (location.hash != "") {
			select(location.hash.substr(1));
		}
		if (!visible) {
			select("file0");
		}
	})();
	</script>
</html>
